* Batch-add a relationship to recordings

Write a userscript that runs on the following url: https://musicbrainz.org/release/c679a438-d704-4b34-97d4-09aeb7064bf8/edit-relationships

Create a button with text "Add instrument" after the text "Track relationships" that executes the following actions when
clicked: Emulate a click on the text "Batch-add a relationship to recordings" located in the following part of the page:

<td><span class="tooltip-wrapper"><button class=
              "add-item with-label batch-add-recording-relationship"
              aria-haspopup="dialog" type="button">Batch-add a relationship to recordings</button></span></td>

Ok, after pressing the button there pops up a dynamically generated dialog (probably react based) with the following content:

#+begin_example
<div class="form">
  <div class="dialog-titlebar">
    <h1>Add relationship
    </h1>
    <div class="buttons-right">
      <span style="font-weight: normal;">(
	<a href="#">help
	</a>)
      </span>
    </div>
  </div>
  <p>This will add a relationship to all checked recordings.
  </p>
  <table class="relationship-details">
    <tbody>
      <tr>
	<td class="required section">Recording
	</td>
	<td class="fields">(31 recordings selected)
	</td>
      </tr>
      <tr>
	<td class="required section">Related type
	</td>
	<td class="fields">
	  <select class="entity-type">
	    <option value="area">Area
	    </option>
	    <option value="artist">Artist
	    </option>
	    <option value="event">Event
	    </option>
	    <option value="label">Label
	    </option>
	    <option value="place">Place
	    </option>
	    <option value="recording">Recording
	    </option>
	    <option value="release">Release
	    </option>
	    <option value="series">Series
	    </option>
	    <option value="work">Work
	    </option>
	  </select>
	</td>
      </tr>
    </tbody>
  </table>
  <h2>
    <div class="heading-line">
    </div>
    <span class="heading-text">Relationship
    </span>
  </h2>
  <table class="relationship-details">
    <tbody>
      <tr>
	<td class="required section">Relationship type
	</td>
	<td class="fields">
	  <label class="autocomplete2-label required" for="relationship-type-artist-recording--915" id="relationship-type-artist-recording--915-label">Type or click to search:
	  </label>
	  <div class="autocomplete2 relationship-type">
	    <div aria-expanded="false" aria-haspopup="listbox" aria-owns="relationship-type-artist-recording--915-menu" class="required" role="combobox">
	      <input aria-autocomplete="list" aria-controls="relationship-type-artist-recording--915-menu" aria-labelledby="relationship-type-artist-recording--915-label" aria-required="true" autocomplete="off" class="relationship-type required" id="relationship-type-artist-recording--915" placeholder="Type or click to search" type="text" value="">
	      <button aria-controls="relationship-type-artist-recording--915-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
	      </button>
	    </div>
	    <ul aria-controls="relationship-type-artist-recording--915-status" aria-labelledby="relationship-type-artist-recording--915-label" id="relationship-type-artist-recording--915-menu" role="listbox" tabindex="-1">
	      <li aria-disabled="true" aria-selected="false" class="disabled header-item " id="relationship-type-artist-recording--915-item-recent-items-header" role="option">Recent items
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-148-recent" role="option">instruments
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed one or more instruments on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-156-recent" role="option">performed / performer
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-149-recent" role="option">vocals
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed vocals on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="action-item " id="relationship-type-artist-recording--915-item-clear-recent-items" role="option">Clear recent items
	      </li>
	      <li aria-disabled="true" aria-selected="false" class="disabled separator option-item " id="relationship-type-artist-recording--915-item-122" role="option">performance
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-156" role="option">performed / performer
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level2 option-item " id="relationship-type-artist-recording--915-item-148" role="option">instruments
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed one or more instruments on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level2 option-item " id="relationship-type-artist-recording--915-item-149" role="option">vocals
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed vocals on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-150" role="option">orchestra
		<br>
		<span class="autocomplete-comment">Indicates an orchestra that performed on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-151" role="option">conducted / conductor
		<br>
		<span class="autocomplete-comment">This indicates an artist who conducted an orchestra, band or choir on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-152" role="option">chorus master
		<br>
		<span class="autocomplete-comment">This indicates the chorus master of a choir which performed on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-760" role="option">concertmaster for / concertmaster
		<br>
		<span class="autocomplete-comment">This indicates an artist who was the concertmaster/leader for an orchestra or band on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-1186" role="option">audio director for / audio director
		<br>
		<span class="autocomplete-comment">This indicates the artist was an audio director for this recording. This is the artist responsible for the creative realization of an audio project (such as an audio drama or audiobook), which is usually based on a written template and involves the performance of voice actors.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-297" role="option">arranged / arranger
		<br>
		<span class="autocomplete-comment">This indicates the artist who arranged a tune into a form suitable for performance. “Arrangement” is used as a catch-all term for all processes that turn a composition into a form that can be played by a specific type of ensemble.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-158" role="option">instruments arranged / instruments arranger
		<br>
		<span class="autocomplete-comment">This indicates the artist who arranged a tune into a form suitable for performance. “Arrangement” is used as a catch-all term for all processes that turn a composition into a form that can be played by a specific type of ensemble.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level2 option-item " id="relationship-type-artist-recording--915-item-300" role="option">orchestrated / orchestrator
		<br>
		<span class="autocomplete-comment">This indicates the person who orchestrated the recording. Orchestration is a special type of arrangement. It means the adaptation of a composition for an orchestra, done in a way that the musical substance remains essentially unchanged. The orchestrator is also responsible for writing scores for an orchestra, band, choral group, individual instrumentalist(s) or vocalist(s). In practical terms it consists of deciding which instruments should play which notes in a piece of music.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-298" role="option">vocals arranged / vocals arranger
		<br>
		<span class="autocomplete-comment">This indicates the artist who arranged a tune into a form suitable for performance. “Arrangement” is used as a catch-all term for all processes that turn a composition into a form that can be played by a specific type of ensemble.
		</span>
	      </li>
	      <li aria-disabled="true" aria-selected="false" class="disabled option-item " id="relationship-type-artist-recording--915-item-157" role="option">remixes and compilations
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-147" role="option">compiled / compiler
		<br>
		<span class="autocomplete-comment">This indicates the person who selected the tracks and the sequence for a compilation. This applies to one long recording which contains multiple songs, one after the other. If the tracks are pitched or blended into each other, it is more appropriate to credit this person as a DJ-mixer.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-155" role="option">DJ-mixed / DJ-mixer
		<br>
		<span class="autocomplete-comment">This links a DJ-mix to the artist who mixed it.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-153" role="option">remixed / remixer
		<br>
		<span class="autocomplete-comment">This links a recording to the person who remixed it by taking one or more other tracks, substantially altering them and mixing them together with other material. Note that this includes the artist who created a mash-up or used samples as well.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-154" role="option">produced material that was sampled in / contains samples by
		<br>
		<span class="autocomplete-comment">Indicates that the recording contains samples from material by the indicated artist. Use this only if you really cannot figure out the particular recording that has been sampled.
		</span>
	      </li>
	      <li aria-disabled="true" aria-selected="false" class="disabled option-item " id="relationship-type-artist-recording--915-item-961" role="option">video
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-858" role="option">appears on video / visual appearances
		<br>
		<span class="autocomplete-comment">This indicates that an artist appears on a music video, but doesn't actually perform on the audio track.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-962" role="option">video director for / video director
		<br>
		<span class="autocomplete-comment">This indicates the artist was the director of this video recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-1243" role="option">animation
		<br>
		<span class="autocomplete-comment">This credits a person or agency who worked on animation for a video recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level1 option-item " id="relationship-type-artist-recording--915-item-1241" role="option">artwork
		<br>
		<span class="autocomplete-comment">This indicates an artist who provided artwork for a video recording when no more specific information is available.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level2 option-item " id="relationship-type-artist-recording--915-item-1242" role="option">design
		<br>
		<span class="autocomplete-comment">This indicates an artist who did design for a video recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="level3 option-item " id="relationship-type-artist-recording--915-item-125" role="option">graphic design
		<br>
		<span class="autocomplete-comment">This credits the people or agency who did the graphic design / layout for a video recording, arranging pieces of content into a coherent and aesthetically-pleasing whole.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="separator action-item " id="relationship-type-artist-recording--915-item-show-more" role="option">Show more...
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="separator action-item " id="relationship-type-artist-recording--915-item-toggle-descriptions" role="option">Hide descriptions
	      </li>
	    </ul>
	    <div aria-live="assertive" aria-relevant="additions text" id="relationship-type-artist-recording--915-status" role="status">
	    </div>
	  </div>
	  <div aria-atomic="true" class="error" role="alert">
	  </div>
	</td>
      </tr>
      <tr>
	<td class="required section">Artist
	</td>
	<td class="fields">
	  <label class="autocomplete2-label required" for="relationship-target--915" id="relationship-target--915-label">Search for an artist:
	  </label>
	  <div class="autocomplete2 relationship-target">
	    <div aria-expanded="false" aria-haspopup="listbox" aria-owns="relationship-target--915-menu" class="required" role="combobox">
	      <input aria-autocomplete="list" aria-controls="relationship-target--915-menu" aria-labelledby="relationship-target--915-label" aria-required="true" autocomplete="off" class="relationship-target required" id="relationship-target--915" placeholder="Type to search, or paste an MBID" type="text" value="">
	      <button aria-controls="relationship-target--915-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
	      </button>
	    </div>
	    <ul aria-controls="relationship-target--915-status" aria-labelledby="relationship-target--915-label" id="relationship-target--915-menu" role="listbox" tabindex="-1">
	      <li aria-disabled="true" aria-selected="false" class="disabled header-item " id="relationship-target--915-item-recent-items-header" role="option">Recent items
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-339449-recent" role="option">Max Weinberg
		<br>
		<span class="autocomplete-comment">Person, 1951-04-13 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-813-recent" role="option">Bruce Springsteen
		<br>
		<span class="autocomplete-comment">Person, 1949-09-23 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-47784-recent" role="option">J.D. Souther
		<br>
		<span class="autocomplete-comment">Person, 1945-11-02 – 2024-09-17
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-1086-recent" role="option">Jackson Browne
		<span class="autocomplete-comment">(American singer-songwriter)
		</span>
		<br>
		<span class="autocomplete-comment">Person, 1948-10-09 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-11058-recent" role="option">Crosby, Stills, Nash &amp; Young
		<br>
		<span class="autocomplete-comment">Group, 1969 – 2015
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-964-recent" role="option">Neil Young
		<span class="autocomplete-comment">(Canadian singer, songwriter &amp; musician)
		</span>
		<br>
		<span class="autocomplete-comment">Person, 1945-11-12 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-1240195-recent" role="option">The E Street Band
		<br>
		<span class="autocomplete-comment">Group, 1972-10 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-131161-recent" role="option">Eddie Vedder
		<br>
		<span class="autocomplete-comment">Person, 1964-12-23 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-target--915-item-713674-recent" role="option">Garry Tallent
		<br>
		<span class="autocomplete-comment">Person, 1949-10-27 –
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="action-item " id="relationship-target--915-item-clear-recent-items" role="option">Clear recent items
	      </li>
	    </ul>
	    <div aria-live="assertive" aria-relevant="additions text" id="relationship-target--915-status" role="status">
	    </div>
	  </div>
	  <div class="error">
	  </div>
	</td>
      </tr>
    </tbody>
  </table>
  <h2>
    <div class="heading-line">
    </div>
    <span class="heading-text">Preview
    </span>
  </h2>
  <p class="required-fields-note">Please fill out all required fields.
  </p>
  <div class="buttons" style="margin-top: 1em;">
    <button class="negative" type="button">Cancel
    </button>
    <div class="buttons-right">
      <button class="positive" disabled="" type="button">Done
      </button>
    </div>
  </div>
</div>
#+end_example

replace the text "Type or click to search:" next to the heading "Relationship type" by entering the text
"instruments". The field in reality (when a human would fill it in) is actually dynamically populated using completion
when typing, possible completing against the musicbrainz database when typing.

#+begin_example
	    <div aria-expanded="false" aria-haspopup="listbox" aria-owns="relationship-type-artist-recording--915-menu" class="required" role="combobox">
	      <input aria-autocomplete="list" aria-controls="relationship-type-artist-recording--915-menu" aria-labelledby="relationship-type-artist-recording--915-label" aria-required="true" autocomplete="off" class="relationship-type required" id="relationship-type-artist-recording--915" placeholder="Type or click to search" type="text" value="">
	      <button aria-controls="relationship-type-artist-recording--915-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
	      </button>
	    </div>
#+end_example

then press the button '<button aria-controls="relationship-type-artist-recording--931-menu" aria-haspopup="true"
aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">'


#+begin_example
<li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--931-item-148-recent" role="option">instruments
<br>
<span class="autocomplete-comment">Indicates an artist that performed one or more instruments on this recording.
</span>
</li>
#+end_example

then press the button '<button aria-controls="relationship-type-artist-recording--931-menu" aria-haspopup="true"
aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">'


Yes it works now.

Now please emulate typing "Max Weinberg" to the "Artist" field, which says "Type to search, or paste an MBID"
and again at the end choose "Max Weinberg" from the popup suggestion list.

Afterwards emulate typing "drums (drum set)" to the "Instrument" field, which says "instrument"
and again at the end choose "drums (drum set)" from the popup suggestion list.

Afterwards emulate a "Tab" to reach the text field which says "Credited as" and type in "drums". Note that this last
field seems to be a normal text field without autocompletion, at least its suggested when a human types in (nothing gets
validated, so you could enter whatever string you want).



Next add "Nils Lofgren" to the "Artist" field (<label class="autocomplete2-label required"
for="relationship-target--945" id="relationship-target--945-label">Search for an artist:</label>) and again emulate
Enter

Finally add "electric guitar" in the "Instrument" field

#+begin_example
// ==UserScript==
// @name         MusicBrainz React Release Batch Instrument Adder
// @namespace    https://musicbrainz.org/
// @version      1.0
// @description  Batch-add the same Artist + Instrument to all recordings on MusicBrainz release edit-relationships (React editor). Test on a non-production edit first.
// @author       ChatGPT (GPT-5 Thinking mini)
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(async function () {
  'use strict';

  // -------- CONFIG --------
  const ARTIST_NAME = 'Nils Lofgren';    // change to your artist
  const INSTRUMENT_NAME = 'electric guitar'; // change to your instrument
  const DEBUG = true;

  // time constants (ms)
  const POLL = 200;
  const SHORT = 200;
  const MED = 450;
  const LONG = 1000;
  const RETRIES = 30;

  function log(...args) { if (DEBUG) console.log('[MB-batch]', ...args); }
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // Robust text matcher (normalize whitespace + lowercase)
  function textContains(node, text) {
    if (!node) return false;
    const s = (node.textContent || '').replace(/\s+/g, ' ').trim().toLowerCase();
    return s.includes((text || '').toLowerCase());
  }

  // find element by tag with visible text includes
  function findByText(tag, text, root = document) {
    const nodes = Array.from(root.querySelectorAll(tag));
    return nodes.find(n => textContains(n, text));
  }

  // wait until predicate true or timeout attempts exhausted
  async function waitFor(predicate, attempts = RETRIES, interval = POLL) {
    for (let i = 0; i < attempts; i++) {
      try {
        const v = predicate();
        if (v) return v;
      } catch (e) { /* ignore */ }
      await sleep(interval);
    }
    return null;
  }

  // simulate user events for inputs
  function setInputValue(el, value) {
    if (!el) return false;
    el.focus();
    // prefer native value set + events
    try {
      const prev = el.value;
      el.value = value;
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      // some React typeaheads need key events
      el.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', bubbles: true }));
      el.dispatchEvent(new KeyboardEvent('keyup', { key: 'a', bubbles: true }));
      el.blur();
      return true;
    } catch (e) {
      try { el.value = value; return true; } catch (e2) { return false; }
    }
  }

  // click element robustly
  function robustClick(el) {
    if (!el) return false;
    try {
      el.scrollIntoView({ block: 'center' });
    } catch (e) {}
    try {
      el.click();
      // try dispatching MouseEvents too
      el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
      el.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
      el.dispatchEvent(new MouseEvent('click', { bubbles: true }));
      return true;
    } catch (e) {
      return false;
    }
  }

  // Heuristic: find the header "select all" checkbox in the recordings column
  async function selectAllRecordings() {
    log('Selecting all recording checkboxes...');
    // try the visible header checkbox (often in table header)
    const headerCheckbox = await waitFor(() => {
      // checkbox input inside a header cell in the left (recordings) column
      const inputs = Array.from(document.querySelectorAll('input[type="checkbox"]'));
      // prefer one that has an aria-label like 'Select all' or is above many track rows
      for (const i of inputs) {
        const label = i.getAttribute('aria-label') || '';
        if (/select all/i.test(label) || /all recordings/i.test(label) || /select all recordings/i.test(label)) return i;
      }
      // fallback: choose a checkbox that is in a header row (closest ancestor th)
      for (const i of inputs) {
        if (i.closest('th')) return i;
      }
      return null;
    }, 8, POLL);

    if (headerCheckbox) {
      robustClick(headerCheckbox);
      await sleep(SHORT);
      log('Header checkbox clicked.');
      return true;
    }

    // fallback: check every visible recording checkbox
    const recCheckboxes = Array.from(document.querySelectorAll('.recording input[type="checkbox"], input.recording-checkbox, input[name^="recording"]'))
      .filter(cb => cb.offsetParent !== null);

    if (recCheckboxes.length) {
      recCheckboxes.forEach(cb => { if (!cb.checked) cb.click(); });
      log(`Checked ${recCheckboxes.length} recording checkboxes (fallback).`);
      return true;
    }

    log('No recording checkboxes found to select.');
    return false;
  }

  // Find & click the Batch-add relationships for recordings button (Tools)
  async function clickBatchAddButton() {
    log('Locating batch-add button...');
    // heuristics: look for buttons/links that contain "Batch-add" and "record" or "recordings"
    const nodes = Array.from(document.querySelectorAll('button, a, [role="button"]'));
    const candidate = nodes.find(n => {
      const t = (n.textContent || '').toLowerCase();
      return t.includes('batch') && (t.includes('record') || t.includes('recording') || t.includes('recordings'));
    });
    if (candidate) {
      robustClick(candidate);
      log('Clicked batch-add button (found by text).');
      return true;
    }

    // Another heuristic: Tools area often contains "Batch-add a relationship to recordings"
    const tools = Array.from(document.querySelectorAll('[data-testid], .tools, .editor-tools, .relationships-tools, .tools-panel')).flat();
    for (const r of tools) {
      const btn = findByText('button, a, [role="button"]', 'Batch-add', r);
      if (btn && (btn.textContent || '').toLowerCase().includes('record')) {
        robustClick(btn);
        log('Clicked batch-add button (found in tools container).');
        return true;
      }
    }

    log('Batch-add button not found.');
    return false;
  }

  // Wait for modal dialog to appear and return it
  async function waitForModalDialog() {
    log('Waiting for modal/dialog...');
    const dlg = await waitFor(() => {
      // any visible element with role dialog / aria-modal / class modal-dialog
      const candidate = Array.from(document.querySelectorAll('[role="dialog"], .modal, .modal-dialog, .dialog')).find(el => el.offsetParent !== null);
      return candidate || null;
    }, RETRIES, POLL);
    if (dlg) log('Modal found.');
    return dlg;
  }

  // choose relationship type = instrument in modal
  async function setRelationshipType(modal) {
    log('Selecting relationship type "instrument"...');

    // Strategy:
    // 1) Find label "Relationship type" or "Type" and then the select/button next to it.
    // 2) If native select element exists, pick matching option.
    // 3) Otherwise open dropdown and select item that contains "instrument".

    const label = Array.from(modal.querySelectorAll('label, .label, span'))
      .find(n => textContains(n, 'relationship type') || textContains(n, 'relationship') && textContains(n, 'type'));

    // attempt to find select near label
    let select = null;
    if (label) {
      // nextElementSibling, parent query
      select = label.parentElement.querySelector('select, [role="combobox"], input, button');
    }

    // fallback: any select in modal whose options include 'instrument'
    if (!select) {
      const selects = Array.from(modal.querySelectorAll('select, [role="combobox"], input, button'));
      for (const s of selects) {
        const text = (s.textContent || '') + ' ' + (s.getAttribute('aria-label') || '') + ' ' + (s.placeholder || '');
        if (text.toLowerCase().includes('relationship') || text.toLowerCase().includes('type')) { select = s; break; }
      }
    }

    // If it's a native <select>
    if (select && select.tagName && select.tagName.toLowerCase() === 'select') {
      // try to match option
      const opt = Array.from(select.options).find(o => (o.text || '').toLowerCase().includes('instrument'));
      if (opt) {
        select.value = opt.value;
        select.dispatchEvent(new Event('change', { bubbles: true }));
        await sleep(MED);
        log('Relationship type set via native select.');
        return true;
      }
    }

    // If it's a combo/button, try clicking to open and pick list item
    if (select) {
      robustClick(select);
      await sleep(MED);
      // find listbox option
      const option = Array.from(document.querySelectorAll('[role="option"], li, button')).find(o => textContains(o, 'instrument'));
      if (option) { robustClick(option); await sleep(MED); log('Relationship type selected via dropdown.'); return true; }
    }

    // fallback: find any option element that includes 'instrument' in modal
    const generalOpt = Array.from(modal.querySelectorAll('*')).find(n => textContains(n, 'instrument') && (n.matches('li') || n.matches('button') || n.matches('[role="option"]')));
    if (generalOpt) { robustClick(generalOpt); await sleep(MED); log('Picked relationship type via general option fallback.'); return true; }

    log('Could not explicitly set relationship type to "instrument". The modal UI may differ.'); 
    return false;
  }

  // set entity type to Artist
  async function setEntityTypeToArtist(modal) {
    log('Setting entity/target type to Artist...');
    // look for a label like 'Entity type' / 'Target type' / 'Entity'
    const label = Array.from(modal.querySelectorAll('label, .label, span')).find(n => textContains(n, 'entity') || textContains(n, 'target') || textContains(n, 'related to') || textContains(n, 'entity type'));
    let selector = null;
    if (label) selector = label.parentElement.querySelector('select, [role="combobox"], button, input');
    if (!selector) selector = modal.querySelector('select, [role="combobox"], input, button');

    if (selector && selector.tagName && selector.tagName.toLowerCase() === 'select') {
      const opt = Array.from(selector.options).find(o => (o.text || '').toLowerCase().includes('artist'));
      if (opt) { selector.value = opt.value; selector.dispatchEvent(new Event('change', { bubbles: true })); await sleep(MED); log('Entity type set via native select.'); return true; }
    }

    if (selector) {
      robustClick(selector);
      await sleep(MED);
      const opt = Array.from(document.querySelectorAll('[role="option"], li, button')).find(o => textContains(o, 'artist'));
      if (opt) { robustClick(opt); await sleep(MED); log('Entity type selected via dropdown.'); return true; }
    }

    // fallback: find any option with text artist
    const anyArtist = Array.from(modal.querySelectorAll('*')).find(n => (textContains(n, 'artist') && (n.matches('li') || n.matches('button') || n.matches('[role="option"]'))));
    if (anyArtist) { robustClick(anyArtist); await sleep(MED); log('Entity type chosen by fallback.'); return true; }

    log('Could not set entity type to Artist explicitly.');
    return false;
  }

  // type target artist and choose suggestion
  async function setTargetArtist(modal, artist) {
    log('Typing artist name:', artist);
    // find input or combobox for the target
    const inputs = Array.from(modal.querySelectorAll('input, [role="combobox"]')).filter(i => i.offsetParent !== null);
    // heuristics: placeholder or aria-label containing 'artist' or 'target' or 'search'
    let targetInput = inputs.find(i => ((i.placeholder || '') + ' ' + (i.getAttribute('aria-label') || '')).toLowerCase().includes('artist') ||
                                                (i.name || '').toLowerCase().includes('artist') || textContains(i.parentElement, 'artist'));
    if (!targetInput) targetInput = inputs[0];

    if (!targetInput) { log('No target input found'); return false; }

    setInputValue(targetInput, artist);
    await sleep(MED + 200);

    // try to pick first suggestion from a listbox
    const suggestion = Array.from(document.querySelectorAll('[role="listbox"] [role="option"], ul[role="listbox"] li, .autocomplete li, .typeahead li')).find(n => textContains(n, artist) || n.textContent.trim().length > 0);
    if (suggestion) {
      robustClick(suggestion);
      await sleep(MED);
      log('Picked artist suggestion.');
      return true;
    }

    // fallback: press Enter in the input to accept top result
    try {
      targetInput.focus();
      targetInput.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
      await sleep(MED);
      log('Sent Enter to accept artist (fallback).');
      return true;
    } catch (e) {
      log('Could not pick artist suggestion.');
      return false;
    }
  }

  // set instrument attribute (if present)
  async function setInstrumentAttribute(modal, instrument) {
    log('Setting instrument attribute:', instrument);
    // find label 'Attribute' / 'Instrument' / 'Relationship attribute'
    const label = Array.from(modal.querySelectorAll('label, span')).find(n => textContains(n, 'attribute') || textContains(n, 'instrument') || textContains(n, 'attribute (instrument)'));
    let attrInput = null;
    if (label) attrInput = label.parentElement.querySelector('input, [role="combobox"], textarea, select');
    if (!attrInput) {
      // fallback: find any input with name or placeholder that looks like attribute/instrument
      attrInput = Array.from(modal.querySelectorAll('input, [role="combobox"], textarea, select')).find(i => ((i.name || '') + ' ' + (i.placeholder || '') + ' ' + (i.getAttribute('aria-label') || '')).toLowerCase().includes('instrument') || ((i.name || '').toLowerCase().includes('attribute')));
    }
    if (!attrInput) {
      log('No instrument attribute input found — maybe relationship attributes are handled differently. Skipping this step.');
      return false;
    }

    setInputValue(attrInput, instrument);
    await sleep(MED);

    // try to choose suggestion
    const suggestion = Array.from(document.querySelectorAll('[role="listbox"] [role="option"], .typeahead li, ul[role="listbox"] li')).find(n => textContains(n, instrument));
    if (suggestion) {
      robustClick(suggestion);
      await sleep(MED);
      log('Picked instrument attribute suggestion.');
      return true;
    }

    // fallback: press Enter to accept
    try {
      attrInput.focus();
      attrInput.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
      await sleep(MED);
      log('Pressed Enter to accept instrument attribute (fallback).');
      return true;
    } catch (e) {
      log('Could not set instrument attribute.');
      return false;
    }
  }

  // finally click the modal Add/Apply button
  async function clickModalApply(modal) {
    log('Trying to confirm/apply the batch-add in modal...');
    // common labels: "Add relationships", "Add", "Apply"
    const btnTexts = ['add relationships', 'add', 'apply', 'save', 'ok'];
    for (const t of btnTexts) {
      const btn = Array.from(modal.querySelectorAll('button, [role="button"]')).find(b => textContains(b, t));
      if (btn) {
        robustClick(btn);
        await sleep(LONG);
        log('Clicked modal button:', t);
        return true;
      }
    }
    log('Could not find an Apply/Add button in modal.');
    return false;
  }

  // Top-level runner
  async function run() {
    log('=== MB Batch Instrument Adder starting ===');
    // 1) select all recordings
    await selectAllRecordings();

    // 2) click Batch-add a relationship to recordings
    const clicked = await clickBatchAddButton();
    if (!clicked) { console.error('[MB-batch] Could not click batch-add button.'); return; }

    // 3) wait for modal
    const modal = await waitForModalDialog();
    if (!modal) { console.error('[MB-batch] Modal did not appear.'); return; }

    // small pause for React rendering
    await sleep(MED);

    // 4) set relationship type to instrument
    await setRelationshipType(modal);

    // 5) set entity type to Artist
    await setEntityTypeToArtist(modal);

    // 6) type & choose artist
    const okArtist = await setTargetArtist(modal, ARTIST_NAME);
    if (!okArtist) log('[MB-batch] Warning: artist selection may have failed.');

    // 7) set instrument attribute (if possible)
    await setInstrumentAttribute(modal, INSTRUMENT_NAME);

    // 8) click Apply/Add
    const okApply = await clickModalApply(modal);
    if (!okApply) console.error('[MB-batch] Could not find/press Apply button. Inspect modal manually.');

    log('=== MB Batch Instrument Adder finished ===');
  }

  // insert a small control button for the user to run the script manually
  function injectControl() {
    if (document.getElementById('mb-batch-instrument-button')) return;
    const heading = Array.from(document.querySelectorAll('h2, h3, h4, .header, .panel-heading')).find(h => textContains(h, 'Track relationships') || textContains(h, 'Relationships') || textContains(h, 'Recording'));
    const container = heading ? heading.parentElement : document.body;
    const btn = document.createElement('button');
    btn.id = 'mb-batch-instrument-button';
    btn.textContent = 'Batch-add Artist+Instrument to all tracks';
    btn.style.cssText = 'margin-left:10px;padding:6px 10px;background:#2b6cb0;color:white;border-radius:4px;border:0;cursor:pointer';
    btn.addEventListener('click', async (e) => {
      btn.disabled = true;
      try {
        await run();
      } catch (err) {
        console.error('[MB-batch] Unexpected error:', err);
      } finally {
        btn.disabled = false;
      }
    });
    if (heading) heading.parentElement.appendChild(btn);
    else document.body.prepend(btn);
  }

  // wait until page ready enough and inject the control button
  await waitFor(() => document.readyState === 'complete' || document.readyState === 'interactive', 20, 200);
  injectControl();
  log('Script loaded. Control button injected (or available).');

})();
#+end_example

#+begin_example
// ==UserScript==
// @name         MusicBrainz React: Batch-add same Instrument to all recordings
// @namespace    https://musicbrainz.org/
// @version      1.0
// @description  On the React release relationship editor page, open the "Batch-add relationships" modal and fill Relationship=Instrument, Target=Artist, Attribute=Instrument then apply to all recordings. Use responsibly; test on a draft/edit you can revert.
// @match        https://musicbrainz.org/release/*/edit-relationships
// @grant        none
// @run-at       document-idle
// ==/UserScript==

/* Notes:
 * - The React editor DOM changes from time to time; this script uses robust text-based matching,
 *   role attributes (combobox/listbox), and retries to cope with dynamic rendering.
 * - If MusicBrainz changes labels (i.e., localized), the button-text matching might need adjusting.
 */

(function () {
  'use strict';

  /* ---------- Configuration ---------- */
  const CONFIG = {
    retryAttempts: 40,
    retryInterval: 200,        // ms between polls
    afterTypeDelay: 450,       // wait after typing into combobox before searching listbox
    verbose: true
  };

  function log(...args) { if (CONFIG.verbose) console.log('[MB-batchA]', ...args); }
  function sleep(ms) { return new Promise((res) => setTimeout(res, ms)); }

  /* ---------- Utilities ---------- */

  // Wait until a function returns a truthy value, or timeout
  async function waitFor(fn, attempts = CONFIG.retryAttempts, interval = CONFIG.retryInterval) {
    for (let i = 0; i < attempts; i++) {
      try {
        const res = fn();
        if (res) return res;
      } catch (e) {
        // ignore errors from fn while DOM is not ready
      }
      await sleep(interval);
    }
    return null;
  }

  // Case-insensitive text matcher for elements
  function elementTextIncludes(el, text) {
    if (!el) return false;
    return (el.textContent || '').toLowerCase().includes(text.toLowerCase());
  }

  // Find a button or element by visible text (partial match). Returns first match.
  function findByText(tagList, text, root = document) {
    const tags = Array.isArray(tagList) ? tagList : [tagList];
    for (const tag of tags) {
      const nodes = Array.from(root.querySelectorAll(tag));
      const found = nodes.find((n) => elementTextIncludes(n, text));
      if (found) return found;
    }
    return null;
  }

  // Emulate robust clicks: focus, mouse events, native click
  function robustClick(el) {
    if (!el) return false;
    try {
      el.focus && el.focus();
      // mouse events
      ['mousedown', 'mouseup', 'click'].forEach((t) => el.dispatchEvent(new MouseEvent(t, { bubbles: true, cancelable: true, view: window })));
      // DOM click
      if (typeof el.click === 'function') el.click();
      return true;
    } catch (e) {
      console.warn('[MB-batchA] robustClick error', e);
      return false;
    }
  }

  // Set value on a combobox-like input and emit events to trigger React typeahead
  function setComboboxInputValue(inputEl, value) {
    if (!inputEl) throw new Error('No input element provided');
    inputEl.focus && inputEl.focus();
    // set value (works for React controlled inputs in many cases if we also dispatch input)
    const prev = inputEl.value;
    inputEl.value = value;
    // create and dispatch events
    const evInput = new Event('input', { bubbles: true });
    inputEl.dispatchEvent(evInput);
    const evChange = new Event('change', { bubbles: true });
    inputEl.dispatchEvent(evChange);
    // small blur/focus sequence sometimes helps
    try { inputEl.blur && inputEl.blur(); } catch {}
    try { inputEl.focus && inputEl.focus(); } catch {}
    // restore previous if empty string requested? we set to desired value already
    return prev;
  }

  // Given a combobox input element, try to pick a listbox option whose text contains 'wantText'
  // Returns true if picked.
  async function pickFromListbox(wantText, root = document, attempts = CONFIG.retryAttempts) {
    for (let i = 0; i < attempts; i++) {
      // listbox: role="listbox" commonly used by react typeaheads; fallback to ul[role=listbox] li
      const listboxes = Array.from(root.querySelectorAll('[role="listbox"], ul, div[role="presentation"]')).filter(Boolean);
      for (const box of listboxes) {
        // options are often role="option" or li/div items
        const opts = Array.from(box.querySelectorAll('[role="option"], li, div')).filter(Boolean);
        if (!opts.length) continue;
        // find best match
        const match = opts.find((o) => elementTextIncludes(o, wantText));
        const opt = match || opts[0];
        if (opt) {
          // try clicking
          robustClick(opt);
          return true;
        }
      }
      await sleep(CONFIG.retryInterval);
    }
    return false;
  }

  /* ---------- UI Panel (small) ---------- */

  function injectPanel() {
    if (document.getElementById('mb-batch-adder-panel')) return;
    const panel = document.createElement('div');
    panel.id = 'mb-batch-adder-panel';
    Object.assign(panel.style, {
      position: 'fixed',
      top: '110px',
      right: '14px',
      width: '320px',
      zIndex: 999999,
      background: '#fff',
      border: '1px solid #bbb',
      padding: '10px',
      borderRadius: '8px',
      boxShadow: '0 6px 18px rgba(0,0,0,0.12)',
      fontFamily: 'Arial, sans-serif',
      fontSize: '13px'
    });

    panel.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong>MB Batch Instrument (A)</strong>
        <button id="mb-batch-close" title="Close" style="border:none;background:transparent;cursor:pointer;font-size:14px">✕</button>
      </div>
      <label style="font-size:12px">Artist (target):</label>
      <input id="mb-batch-artist" placeholder="e.g. Nils Lofgren" style="width:100%;margin-bottom:6px;padding:6px;box-sizing:border-box" />
      <label style="font-size:12px">Instrument (attribute):</label>
      <input id="mb-batch-instrument" placeholder="e.g. electric guitar" style="width:100%;margin-bottom:8px;padding:6px;box-sizing:border-box" />
      <div style="display:flex;gap:6px">
        <button id="mb-batch-run" style="flex:1;padding:8px;border-radius:6px;border:1px solid #333;cursor:pointer;background:#2b6cb0;color:white">Run</button>
        <button id="mb-batch-help" style="padding:8px;border-radius:6px;border:1px solid #777;cursor:pointer">Help</button>
      </div>
      <div id="mb-batch-status" style="margin-top:8px;font-size:12px;color:#333">Idle</div>
    `;
    document.body.appendChild(panel);

    document.getElementById('mb-batch-close').addEventListener('click', () => panel.remove());
    document.getElementById('mb-batch-help').addEventListener('click', showHelp);
    document.getElementById('mb-batch-run').addEventListener('click', runBatchFromUI);
  }

  function showHelp() {
    alert('This script will open MusicBrainz\'s "Batch-add relationships" modal and fill:\n\n- Relationship type: Instrument\n- Target: Artist (the name you entered)\n- Attribute (instrument): Instrument (the name you entered)\n\nAfter running, verify the modal and click the final Apply/Done button yourself to avoid accidental mass edits.\n\nIf something doesn\'t work, open the browser console to see logs.');
  }

  /* ---------- Core automation flow for Option A ---------- */

  async function runBatchFromUI() {
    const artist = (document.getElementById('mb-batch-artist').value || '').trim();
    const instr = (document.getElementById('mb-batch-instrument').value || '').trim();
    const statusEl = document.getElementById('mb-batch-status');

    if (!artist || !instr) {
      alert('Please enter both Artist and Instrument.');
      return;
    }

    statusEl.textContent = 'Starting: attempting to open Batch-add modal...';
    log('Requested batch add for artist=', artist, 'instrument=', instr);

    // 1) Find and click the existing "Batch-add relationships" button (text match).
    // Try multiple text variants to be robust.
    const batchBtnTextCandidates = [
      'Batch-add relationships',
      'Batch add relationships',
      'Batch-add a relationship to recordings',
      'Batch-add a relationship'
    ];

    let batchBtn = null;
    for (const txt of batchBtnTextCandidates) {
      batchBtn = findByText(['button', 'a', 'div'], txt);
      if (batchBtn) break;
    }

    if (!batchBtn) {
      // fallback: try heading "Track relationships" and find sibling button
      const heading = findByText(['h2','h3','h4','legend'], 'Track relationships') || findByText(['h2','h3','h4','legend'], 'Relationships');
      if (heading) {
        // look for a button near heading
        const nearbyBtn = heading.parentElement ? heading.parentElement.querySelector('button, a') : null;
        if (nearbyBtn) batchBtn = nearbyBtn;
      }
    }

    if (!batchBtn) {
      statusEl.textContent = 'ERROR: Could not find Batch-add button on page. See console.';
      console.error('[MB-batchA] Could not locate Batch-add relationships button.');
      return;
    }

    // click to open modal
    robustClick(batchBtn);
    statusEl.textContent = 'Batch modal opened (or clicked). Waiting for modal...';
    log('Clicked batch button, waiting for modal...');

    // 2) Wait for modal to appear. We look for role="dialog" or an element with text "Batch" and "Relationship".
    const modal = await waitFor(() => {
      // typical React modal has role dialog
      const m1 = document.querySelector('[role="dialog"]');
      if (m1 && elementTextIncludes(m1, 'Batch')) return m1;
      // fallback: modal container with "Batch" text
      const nodes = Array.from(document.querySelectorAll('div')).filter(n => elementTextIncludes(n, 'Batch') && n.querySelector('input, [role="combobox"]'));
      if (nodes.length) return nodes[0];
      return null;
    }, CONFIG.retryAttempts, CONFIG.retryInterval);

    if (!modal) {
      statusEl.textContent = 'ERROR: Batch modal did not appear. See console.';
      console.error('[MB-batchA] Batch modal not found.');
      return;
    }
    log('Modal found:', modal);
    statusEl.textContent = 'Modal detected. Filling relationship type...';

    // 3) Relationship Type: find the combobox/select that sets type and set to 'instrument' (or variant)
    // Look for labels nearby that say "Relationship type", or find combobox with placeholder "Search" etc.
    const typeCandidates = Array.from(modal.querySelectorAll('input[role="combobox"], input[type="text"], select')).filter(Boolean);
    let typeInput = null;
    // Heuristics: label text, aria-label, placeholder
    for (const el of typeCandidates) {
      const lab = (el.getAttribute('aria-label') || '') + ' ' + (el.placeholder || '') + ' ' + ((el.labels && el.labels[0] && el.labels[0].textContent) || '');
      if (lab.toLowerCase().includes('relationship') || lab.toLowerCase().includes('type')) {
        typeInput = el;
        break;
      }
    }
    // fallback: first combobox in modal
    if (!typeInput) typeInput = typeCandidates.find(e => e.getAttribute('role') === 'combobox') || typeCandidates[0];

    if (!typeInput) {
      statusEl.textContent = 'ERROR: Could not find Relationship Type input. See console.';
      console.error('[MB-batchA] Relationship Type input not found in modal.', modal);
      return;
    }

    // Set relationship type to "instrument" (try plural/singular)
    setComboboxInputValue(typeInput, 'instrument');
    await sleep(CONFIG.afterTypeDelay);

    // pick from listbox
    const pickedType = await pickFromListbox('instrument', modal);
    log('Picked relationship type:', pickedType);
    if (!pickedType) {
      console.warn('[MB-batchA] Could not pick "instrument" option automatically; leaving typed text and continuing.');
    }
    statusEl.textContent = 'Relationship type set. Filling artist (Target)...';

    // 4) Target (Artist) combobox: find the next combobox after the type input or labeled 'Target' or 'Artist'
    // We'll search inputs in modal and prefer those with aria-label/placeholder mentioning 'target'/'artist'/'entity'.
    const inputs = Array.from(modal.querySelectorAll('input[role="combobox"], input[type="text"], textarea')).filter(Boolean);
    let artistInput = null;
    for (const el of inputs) {
      const meta = ((el.getAttribute('aria-label') || '') + ' ' + (el.placeholder || '') + ' ' + (el.getAttribute('name') || '') + ' ' + ((el.labels && el.labels[0] && el.labels[0].textContent) || '')).toLowerCase();
      if (meta.includes('target') || meta.includes('artist') || meta.includes('entity') || meta.includes('artist/target')) { artistInput = el; break; }
    }
    // fallback: the input after typeInput in DOM order
    if (!artistInput && typeInput) {
      const idx = inputs.indexOf(typeInput);
      if (idx >= 0 && inputs[idx + 1]) artistInput = inputs[idx + 1];
    }
    // final fallback: first combobox different from typeInput
    if (!artistInput) artistInput = inputs.find(i => i !== typeInput);

    if (!artistInput) {
      statusEl.textContent = 'ERROR: Could not find Target/Artist input. See console.';
      console.error('[MB-batchA] Artist/target input not found in modal.', modal);
      return;
    }

    // set artist
    setComboboxInputValue(artistInput, artist);
    await sleep(CONFIG.afterTypeDelay);
    const pickedArtist = await pickFromListbox(artist, modal);
    log('Picked artist option:', pickedArtist);
    if (!pickedArtist) console.warn('[MB-batchA] Artist option not picked automatically; please pick manually in modal.');

    statusEl.textContent = 'Artist set. Filling instrument attribute...';

    // 5) Attribute / Instrument input: many editors place attributes in a separate "attribute" input field.
    // Find an input whose label/aria mentions 'instrument' or 'attribute'
    let attrInput = null;
    for (const el of inputs) {
      const meta = ((el.getAttribute('aria-label') || '') + ' ' + (el.placeholder || '') + ' ' + ((el.labels && el.labels[0] && el.labels[0].textContent) || '')).toLowerCase();
      if (meta.includes('instrument') || meta.includes('attribute') || meta.includes('role')) { attrInput = el; break; }
    }
    // If not found, search for any input inside modal that seems like "attribute" area using nearby label text in DOM
    if (!attrInput) {
      const labels = Array.from(modal.querySelectorAll('label')).filter(Boolean);
      const instrumentLabel = labels.find(l => elementTextIncludes(l, 'Instrument') || elementTextIncludes(l, 'attribute'));
      if (instrumentLabel && instrumentLabel.htmlFor) {
        attrInput = modal.querySelector('#' + CSS.escape(instrumentLabel.htmlFor));
      }
    }
    // final fallback: try to find a small text input near the bottom of modal
    if (!attrInput) {
      const smallInputs = inputs.filter(i => (i.offsetWidth || 0) < 600);
      if (smallInputs.length) attrInput = smallInputs[smallInputs.length - 1];
    }

    if (!attrInput) {
      // Attribute field may be rendered only after selecting target/type. Warn but continue.
      console.warn('[MB-batchA] Attribute input not detected automatically. The modal may present attribute fields inline or as a separate component. You may need to fill instrument manually.');
      statusEl.textContent = 'Attribute input not found automatically — please fill Instrument manually in modal.';
      return;
    }

    // Fill attribute (instrument)
    setComboboxInputValue(attrInput, instr);
    await sleep(CONFIG.afterTypeDelay);
    const pickedAttr = await pickFromListbox(instr, modal);
    log('Picked attribute option:', pickedAttr);
    if (!pickedAttr) console.warn('[MB-batchA] Could not pick attribute option automatically; please pick it manually.');

    statusEl.textContent = 'Fields filled. Please review the modal and click the final "Add relationships" / "Apply" / "Done" button to complete the edit.';

    // Attempt to click modal "Add relationships" or "Apply" automatically as a convenience,
    // but DO NOT force final submit if you prefer to inspect.
    const finishBtnCandidates = ['Add relationships', 'Apply', 'Apply to selected recordings', 'Add relationship', 'Save', 'Done'];
    for (const txt of finishBtnCandidates) {
      const btn = findByText(['button', 'a', 'div'], txt, modal);
      if (btn) {
        log('Attempting to click finish button:', txt, btn);
        robustClick(btn);
        statusEl.textContent = `Clicked "${txt}". If nothing happened, please click it manually.`;
        break;
      }
    }

    log('runBatchFromUI finished; user should verify modal and finalise.');
  }

  /* ---------- Init ---------- */
  function init() {
    injectPanel();
    log('MB batch-instrument (Option A) script initialised. Panel injected.');
  }

  // Wait for page to be interactive and inject panel
  window.addEventListener('load', () => {
    setTimeout(init, 700);
  });

  // also try immediate init if DOM already loaded
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(init, 500);
  }

})();
#+end_example

** new logic - 1

#+begin_example
// ==UserScript==
// @name         AA - Minimal Add Instrument Button (react release editor)
// @namespace    https://musicbrainz.org/
// @version      1.1
// @description  Adds a button after “Track relationships” header and triggers batch-add button. Includes fallback DOM logging.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument-btn]', ...args);
    }

    /** Wait until fn() returns non-null, or timeout. */
    async function waitFor(fn, attempts = 30, interval = 300) {
        for (let i = 0; i < attempts; i++) {
            try {
                const v = fn();
                if (v) return v;
            } catch (e) {}
            await new Promise(r => setTimeout(r, interval));
        }
        return null;
    }

    /** Creates a detailed log of every <button> and <a> on the page. */
    function logAllButtonsAndLinks() {
        const elements = Array.from(document.querySelectorAll('button, a'));

        console.group('[AA] Fallback: listing all buttons and links (' + elements.length + ')');
        elements.forEach((el, idx) => {
            console.group('Element #' + idx);
            console.log('Text:', el.textContent.trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('Aria:', {
                label: el.getAttribute('aria-label'),
                haspopup: el.getAttribute('aria-haspopup'),
                pressed: el.getAttribute('aria-pressed'),
            });
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();

        alert(
            "AA Script: could NOT find the batch-add button.\n\n" +
            "I logged ALL <button> and <a> elements in console.\n" +
            "Open the browser console and search for the real button."
        );
    }

    /** Insert our “Add instrument” button */
    async function insertButton() {
        const heading = Array.from(document.querySelectorAll('h1, h2, h3, h4, .section-header, .header'))
            .find(el => (el.textContent || '').toLowerCase().includes('track relationships'));

        if (!heading) {
            log('Heading “Track relationships” not found yet — retrying…');
            return false;
        }

        // avoid double insertion
        if (document.getElementById('aa-add-instrument-btn')) return true;

        const btn = document.createElement('button');
        btn.id = 'aa-add-instrument-btn';
        btn.textContent = 'Add instrument';
        btn.style.marginLeft = '10px';
        btn.style.padding = '4px 8px';
        btn.style.border = '1px solid #444';
        btn.style.borderRadius = '4px';
        btn.style.background = '#0066cc';
        btn.style.color = 'white';
        btn.style.cursor = 'pointer';

        btn.addEventListener('click', () => {
            log('Custom button clicked — trying to trigger batch-add button…');

            // First attempt: exact selector you provided
            const exact = document.querySelector(
                'button.add-item.with-label.batch-add-recording-relationship'
            );
            if (exact) {
                log('Found batch-add button by exact class — clicking.');
                exact.click();
                return;
            }

            // Second attempt: text-based search
            const candidates = Array.from(document.querySelectorAll('button, a'));
            const match = candidates.find(el => {
                const t = (el.textContent || '').toLowerCase();
                return t.includes('batch-add') && (t.includes('record') || t.includes('recording'));
            });

            if (match) {
                log('Found batch-add button by text fallback — clicking:', match);
                match.click();
                return;
            }

            // If all failed → log everything
            console.error('[AA] Could NOT find the batch-add button!');
            logAllButtonsAndLinks();
        });

        // Add our button after the heading
        heading.insertAdjacentElement('afterend', btn);
        log('Injected custom “Add instrument” button.');
        return true;
    }


    // Start trying to insert button (React may delay rendering)
    (async () => {
        const ok = await waitFor(insertButton, 40, 500);
        if (!ok) console.warn('[AA] Could not insert Add instrument button — giving up.');
    })();

})();
#+end_example

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor)
// @namespace    https://musicbrainz.org/
// @version      1.3
// @description  Insert “Add instrument (React)” button after Track relationships and trigger batch-add button. Includes fallback logging.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();

        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Button injected next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const $batch = $("button.add-item.with-label.batch-add-recording-relationship");

            if ($batch.length) {
                log("Found batch-add button by exact match → clicking.");
                $batch[0].click();
                return;
            }

            log("Exact match failed → trying text-based fallback…");

            const $fallback = $("button, a").filter((i, el) => {
                const t = $(el).text().toLowerCase();
                return t.includes("batch-add") && (t.includes("record") || t.includes("recording"));
            });

            if ($fallback.length) {
                log("Found batch-add button by text fallback → clicking.");
                $fallback[0].click();
                return;
            }

            log("Batch-add button NOT found → dumping all buttons for inspection.");
            logAllButtonsAndLinks();
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

** with working "instruments"

Please extend the following working userscript:

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor)
// @namespace    https://musicbrainz.org/
// @version      1.4
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments".
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    /** Dumps all buttons & links in case selectors fail */
    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();

        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    /** Simulate real typing so React autocomplete updates correctly */
function typeIntoAutocomplete($input, text) {
    const el = $input[0];
    el.focus();

    let idx = 0;

    function reactInput(el, newValue) {
        const last = el.value;
        el.value = newValue;

        const e = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: newValue.replace(last, "")
        });

        el.dispatchEvent(e);
    }

    function clickInstrumentsOption() {
        // Find the dropdown item labeled "instruments" (case-insensitive)
        const $opt = $("li[role='option']").filter((i, el) =>
            $(el).text().trim().toLowerCase().startsWith("instruments")
        );

        if ($opt.length) {
            log("Clicking dropdown option: instruments");
            $opt[0].click();
        } else {
            log("Dropdown list not ready yet → retrying…");
            setTimeout(clickInstrumentsOption, 100);
        }
    }

    function typeNext() {
        if (idx >= text.length) {
            // After typing, give React time to populate the dropdown
            setTimeout(clickInstrumentsOption, 150);
            return;
        }

        const ch = text[idx];
        const newValue = el.value + ch;
        reactInput(el, newValue);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}

    /** After the dialog appears, fill in the 'Relationship type' field with "instruments" */
    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments");
    }

    /** MAIN: Create the custom button next to "Track relationships" */
    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        // Insert next to heading
        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        // Button click = open dialog
        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

with the following functionality.

After filling in the "instruments" into the "Relationship type" field...

Please emulate typing "Max Weinberg" to the "Artist" field, which says "Type to search, or paste an MBID"
and again at the end choose "Max Weinberg" from the popup suggestion list.

Afterwards emulate typing "drums (drum set)" to the "Instrument" field, which says "instrument"
and again at the end choose "drums (drum set)" from the popup suggestion list.

Afterwards emulate a "Tab" to reach the text field which says "Credited as" and type in "drums". Note that this last
field seems to be a normal text field without autocompletion, at least its suggested when a human types in (nothing gets
validated, so you could enter whatever string you want).

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

    function
#+end_example

Everything works up to filling in "drums (drum set)", but the tabbing in the next empty field (which holds the text "Credited as" as a hint) doesn't work.
Instead the console output shows

#+begin_example
[AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] AA: Injected custom button next to 'Track relationships'.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Custom button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Max Weinberg
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: drums (drum set)
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled.
edit-relationships:1 Blocked aria-hidden on an element because its descendant retained focus. The focus must not be hidden from assistive technology users. Avoid using aria-hidden on a focused element or its ancestor. Consider using the inert attribute instead, which will also prevent focus. For more details, see the aria-hidden section of the WAI-ARIA specification at https://w3c.github.io/aria/#aria-hidden.
Element with focus: <input#headerid-query>
Ancestor with aria-hidden: <div.header> <div class=​"header" data-floating-ui-inert aria-hidden=​"true">​…​</div>​
#+end_example

I now get

#+begin_example
[AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] AA: Injected custom button next to 'Track relationships'.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Custom button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Max Weinberg
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: drums (drum set)
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled successfully.
edit-relationships:1 Blocked aria-hidden on an element because its descendant retained focus. The focus must not be hidden from assistive technology users. Avoid using aria-hidden on a focused element or its ancestor. Consider using the inert attribute instead, which will also prevent focus. For more details, see the aria-hidden section of the WAI-ARIA specification at https://w3c.github.io/aria/#aria-hidden.
Element with focus: <input#headerid-query>
Ancestor with aria-hidden: <div.header> <div class=​"header" data-floating-ui-inert aria-hidden=​"true">​…​</div>​Understand this warning
#+end_example


It's still not working. Here is the complete generated HTML code up to the point when the text "drums" should be inserted 

#+begin_example
<div class="form">
  <div class="dialog-titlebar">
    <h1>Add relationship
    </h1>
    <div class="buttons-right">
      <span style="font-weight: normal;">(
	<a href="#">help
	</a>)
      </span>
    </div>
  </div>
  <p>This will add a relationship to all checked recordings.
  </p>
  <table class="relationship-details">
    <tbody>
      <tr>
	<td class="required section">Recording
	</td>
	<td class="fields">(31 recordings selected)
	</td>
      </tr>
      <tr>
	<td class="required section">Related type
	</td>
	<td class="fields">
	  <select class="entity-type">
	    <option value="area">Area
	    </option>
	    <option value="artist">Artist
	    </option>
	    <option value="event">Event
	    </option>
	    <option value="label">Label
	    </option>
	    <option value="place">Place
	    </option>
	    <option value="recording">Recording
	    </option>
	    <option value="release">Release
	    </option>
	    <option value="series">Series
	    </option>
	    <option value="work">Work
	    </option>
	  </select>
	</td>
      </tr>
    </tbody>
  </table>
  <h2>
    <div class="heading-line">
    </div>
    <span class="heading-text">Relationship
    </span>
  </h2>
  <table class="relationship-details">
    <tbody>
      <tr>
	<td class="required section">Relationship type
	</td>
	<td class="fields">
	  <label class="autocomplete2-label required" for="relationship-type-artist-recording--915" id="relationship-type-artist-recording--915-label">Type or click to search:
	  </label>
	  <div class="autocomplete2 relationship-type">
	    <div aria-expanded="false" aria-haspopup="listbox" aria-owns="relationship-type-artist-recording--915-menu" class="required" role="combobox">
	      <input aria-autocomplete="list" aria-controls="relationship-type-artist-recording--915-menu" aria-labelledby="relationship-type-artist-recording--915-label" aria-required="true" autocomplete="off" class="relationship-type lookup-performed" id="relationship-type-artist-recording--915" placeholder="Type or click to search" type="text" value="instruments">
	      <button aria-controls="relationship-type-artist-recording--915-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
	      </button>
	    </div>
	    <ul aria-controls="relationship-type-artist-recording--915-status" aria-labelledby="relationship-type-artist-recording--915-label" id="relationship-type-artist-recording--915-menu" role="listbox" tabindex="-1">
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-148" role="option">instruments
		<br>
		<span class="autocomplete-comment">Indicates an artist that performed one or more instruments on this recording.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-158" role="option">instruments arranged / instruments arranger
		<br>
		<span class="autocomplete-comment">This indicates the artist who arranged a tune into a form suitable for performance. “Arrangement” is used as a catch-all term for all processes that turn a composition into a form that can be played by a specific type of ensemble.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="option-item " id="relationship-type-artist-recording--915-item-986" role="option">instruments technician for / instruments technician
		<br>
		<span class="autocomplete-comment">Indicates the instrument technician for this recording. Use also for "piano tuner" credits and other similar ones.
		</span>
	      </li>
	      <li aria-disabled="false" aria-selected="false" class="separator action-item " id="relationship-type-artist-recording--915-item-toggle-descriptions" role="option">Hide descriptions
	      </li>
	    </ul>
	    <div aria-live="assertive" aria-relevant="additions text" id="relationship-type-artist-recording--915-status" role="status">instruments
	    </div>
	  </div>
	  <div aria-atomic="true" class="error" role="alert">
	  </div>
	</td>
      </tr>
      <tr>
	<td class="required section">Artist
	</td>
	<td class="fields">
	  <label class="autocomplete2-label required" for="relationship-target--915" id="relationship-target--915-label">Search for an artist:
	  </label>
	  <div class="autocomplete2 relationship-target">
	    <div aria-expanded="false" aria-haspopup="listbox" aria-owns="relationship-target--915-menu" class="required" role="combobox">
	      <input aria-autocomplete="list" aria-controls="relationship-target--915-menu" aria-labelledby="relationship-target--915-label" aria-required="true" autocomplete="off" class="relationship-target lookup-performed" id="relationship-target--915" placeholder="Type to search, or paste an MBID" type="text" value="Max Weinberg">
	      <button aria-controls="relationship-target--915-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
	      </button>
	    </div>
	    <ul aria-controls="relationship-target--915-status" aria-labelledby="relationship-target--915-label" id="relationship-target--915-menu" role="listbox" tabindex="-1">
	    </ul>
	    <div aria-live="assertive" aria-relevant="additions text" id="relationship-target--915-status" role="status">Max Weinberg
	    </div>
	  </div>
	  <div class="error">
	  </div>
	  <div class="target-entity-credit">
	    <input aria-description="A credited name is optional. You can leave this field blank to keep the current name." aria-label="Credited as" class="entity-credit" id=":rr1:" placeholder="Credited as" type="text" value="">
	    <span class="tooltip-wrapper">
	      <span class="img icon help" style="display: inline-block; margin-left: 10px; vertical-align: text-top;">
	      </span>
	      <span class="tooltip-container">
		<span class="tooltip-triangle">
		</span>
		<span class="tooltip-content">A credited name is optional. You can leave this field blank to keep the current name.
		</span>
	      </span>
	    </span>
	  </div>
	</td>
      </tr>
    </tbody>
  </table>
  <h2>
    <div class="heading-line">
    </div>
    <span class="heading-text">Attributes
    </span>
  </h2>
  <table class="relationship-details">
    <tbody>
      <tr>
	<td class="section">
	</td>
	<td class="fields">
	  <div class="attribute-container checkbox additional">
	    <label>
	      <input class="boolean" id="additional-checkbox" type="checkbox"> additional
	    </label>
	  </div>
	</td>
      </tr>
      <tr>
	<td class="section">
	</td>
	<td class="fields">
	  <div class="attribute-container checkbox guest">
	    <label>
	      <input class="boolean" id="guest-checkbox" type="checkbox"> guest
	    </label>
	  </div>
	</td>
      </tr>
      <tr>
	<td class="section">
	</td>
	<td class="fields">
	  <div class="attribute-container checkbox solo">
	    <label>
	      <input class="boolean" id="solo-checkbox" type="checkbox"> solo
	    </label>
	  </div>
	</td>
      </tr>
      <tr>
	<td class="section">Instrument
	</td>
	<td class="fields">
	  <div class="attribute-container multiselect instrument">
	    <div class="multiselect-value">
	      <label class="autocomplete2-label" for="attribute-924" id="attribute-924-label">instrument:
	      </label>
	      <div class="autocomplete2">
		<div aria-expanded="false" aria-haspopup="listbox" aria-owns="attribute-924-menu" role="combobox">
		  <input aria-autocomplete="list" aria-controls="attribute-924-menu" aria-labelledby="attribute-924-label" aria-required="false" autocomplete="off" class="lookup-performed" id="attribute-924" placeholder="instrument" type="text" value="drums (drum set)">
		  <button aria-controls="attribute-924-menu" aria-haspopup="true" aria-label="Search" class="search" data-toggle="true" role="button" tabindex="-1" title="Search" type="button">
		  </button>
		</div>
		<ul aria-controls="attribute-924-status" aria-labelledby="attribute-924-label" id="attribute-924-menu" role="listbox" tabindex="-1">
		  <li aria-disabled="false" aria-selected="false" class="option-item " id="attribute-924-item-126" role="option">drums (drum set)
		    <span class="autocomplete-comment">(Set of drums in modern music, Percussion instrument)
		    </span>
		    <br>
		    <span class="autocomplete-comment">Set of drums developed from the 1930's onward, it is used in Jazz, Swing, Rock and Pop music. It consists of snare drum, tom-toms, hi-hats, cymbals and bass drum.
		    </span>
		  </li>
		  <li aria-disabled="false" aria-selected="false" class="separator action-item " id="attribute-924-item-toggle-descriptions" role="option">Hide descriptions
		  </li>
		</ul>
		<div aria-live="assertive" aria-relevant="additions text" id="attribute-924-status" role="status">drums (drum set)
		</div>
	      </div>
	      <input aria-label="Credited as" class="attribute-credit" placeholder="Credited as" type="text" value="">
	      <button aria-disabled="false" class="remove-item icon" title="Remove" type="button">
	      </button>
	    </div>
	    <button class="add-item with-label" type="button"> Add instrument
	    </button>
	  </div>
	</td>
      </tr>
      <tr>
	<td class="section">
	  <label for="id-period.begin_date.year">Begin date
	  </label>
	</td>
	<td class="fields">
	  <span class="partial-date">
	    <input class="partial-date-year" id="id-period.begin_date.year" maxlength="4" name="period.begin_date.year" placeholder="YYYY" size="4" type="text" value="">-
	    <input class="partial-date-month" id="id-period.begin_date.month" maxlength="2" name="period.begin_date.month" placeholder="MM" size="2" type="text" value="">-
	    <input class="partial-date-day" id="id-period.begin_date.day" maxlength="2" name="period.begin_date.day" placeholder="DD" size="2" type="text" value="">
	  </span>
	  <button class="icon copy-date" title="Copy to end date" type="button">
	  </button>
	</td>
      </tr>
      <tr>
	<td class="section">
	  <label for="id-period.end_date.year">End date
	  </label>
	</td>
	<td class="fields end-date">
	  <span class="partial-date">
	    <input class="partial-date-year" id="id-period.end_date.year" maxlength="4" name="period.end_date.year" placeholder="YYYY" size="4" type="text" value="">-
	    <input class="partial-date-month" id="id-period.end_date.month" maxlength="2" name="period.end_date.month" placeholder="MM" size="2" type="text" value="">-
	    <input class="partial-date-day" id="id-period.end_date.day" maxlength="2" name="period.end_date.day" placeholder="DD" size="2" type="text" value="">
	  </span>
	  <br>
	  <div class="row">
	    <label class="inline">
	      <input id="id-period.ended" name="period.ended" type="checkbox" value="1"> This relationship has ended.
	    </label>
	  </div>
	</td>
      </tr>
    </tbody>
  </table>
  <h2>
    <div class="heading-line">
    </div>
    <span class="heading-text">Preview
    </span>
  </h2>
  <table class="preview details add-relationship">
    <tbody>
      <tr>
	<th>Relationship:
	</th>
	<td>
	  <a class="wrap-anywhere" target="_blank" href="/artist/2566ca73-1dfd-49e7-ab20-dfa5697b360e" title="Weinberg, Max">
	    <bdi>Max Weinberg
	    </bdi>
	  </a> performed
	  <a href="/instrument/12092505-6ee1-46af-a15a-b5b468b6b155">drums (drum set)
	  </a> on
	  <span class="tooltip" title="(31 recordings selected)">
	    <bdi>[selected recording]
	    </bdi>
	  </span>
	</td>
      </tr>
    </tbody>
  </table>
  <div class="buttons" style="margin-top: 1em;">
    <button class="negative" type="button">Cancel
    </button>
    <div class="buttons-right">
      <button class="positive" type="button">Done
      </button>
    </div>
  </div>
</div>
#+end_example

and here is the relevant part where it says "Credited as"

#+begin_example
	      <input aria-label="Credited as" class="attribute-credit" placeholder="Credited as" type="text" value="">
	      <button aria-disabled="false" class="remove-item icon" title="Remove" type="button">
#+end_example

The console output is

#+begin_example
[AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] AA: Injected custom button next to 'Track relationships'.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Custom button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Max Weinberg
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: drums (drum set)
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled successfully.
#+end_example

but still NOTHING gets inserted

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    // Find the last instrument multiselect container (the one we just filled)
    const $instrumentContainer = $('.multiselect.instrument').last();

    if ($instrumentContainer.length === 0) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');

    if ($creditedInput.length === 0) {
        log("'Credited as' input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    const value = "drums";

    // Clear first
    el.value = "";

    // Type character by character
    for (let i = 0; i < value.length; i++) {
        el.value += value[i];
        el.dispatchEvent(new Event('input', { bubbles: true }));
    }

    // Final change event to ensure React picks it up
    el.dispatchEvent(new Event('change', { bubbles: true }));

    log("'Credited as' field filled successfully.");
}

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example


#+begin_example
function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];
        const newValue = el.value + ch;
        el.value = newValue;

        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });
        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}
#+end_example

#+begin_example
function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');
    if (!$creditedInput.length) {
        log("'Credited as' input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    typeIntoReactInput(el, "drums", () => {
        log("'Credited as' field filled successfully.");
    });
}
#+end_example

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];
        const newValue = el.value + ch;
        el.value = newValue;

        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });
        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}

function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');
    if (!$creditedInput.length) {
        log("'Credited as' input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    typeIntoReactInput(el, "drums", () => {
        log("'Credited as' field filled successfully.");
    });
}

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

Now it works, but it only inserts "rums", instead of "drums".

#+begin_example
function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];

        // Create InputEvent without modifying el.value directly
        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });

        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}
#+end_example


#+begin_example
const $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit');
typeIntoReactInput($creditedInput[0], "drums", () => {
    console.log("'Credited as' field filled successfully.");
});
#+end_example

** this is the good version and should be replae with the two code examples from above

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];

        // Create InputEvent without modifying el.value directly
        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });

        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}

function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');
    if (!$creditedInput.length) {
        log("'Credited as' input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    typeIntoReactInput(el, "drums", () => {
        log("'Credited as' field filled successfully.");
    });
}

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

** latest version

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type, artist, instrument, and credited-as.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    /** Dumps all buttons & links in case selectors fail */
    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    /** Typing helper compatible with React inputs */
    function typeIntoReactInput(el, text, callback) {
        el.focus({ preventScroll: true });
        let idx = 0;

        function typeNext() {
            if (idx >= text.length) {
                if (callback) callback();
                return;
            }

            const ch = text[idx];

            const inputEvent = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: ch,
            });

            el.dispatchEvent(inputEvent);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    /** Fill Relationship type field with "instruments" */
    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoReactInput($input[0], "instruments", fillArtistField);
    }

    /** Fill Artist field with "Max Weinberg" */
    function fillArtistField() {
        log("Filling Artist field…");

        const $input = $('input.relationship-target:visible');

        if ($input.length === 0) {
            log("Artist field not found yet — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoReactInput($input[0], "Max Weinberg", () => {
            // After typing, choose first dropdown option
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase() === "max weinberg"
            );
            if ($opt.length) {
                log("Clicking dropdown option: Max Weinberg");
                $opt[0].click();
            }
            setTimeout(fillInstrumentField, 150);
        });
    }

    /** Fill Instrument field with "drums (drum set)" */
    function fillInstrumentField() {
        log("Filling Instrument field…");

        const $input = $('.multiselect.instrument input.lookup-performed:visible').last();

        if ($input.length === 0) {
            log("Instrument field not found yet — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoReactInput($input[0], "drums (drum set)", () => {
            // After typing, click dropdown option
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase() === "drums (drum set)"
            );
            if ($opt.length) {
                log("Clicking dropdown option: drums (drum set)");
                $opt[0].click();
            }
            setTimeout(fillCreditedAsField, 150);
        });
    }

    /** Fill Credited as field with "drums" */
    function fillCreditedAsField() {
        log("Filling 'Credited as' field…");

        const $container = $('.multiselect.instrument').last();
        if (!$container.length) {
            log("Instrument container not found — retrying…");
            setTimeout(fillCreditedAsField, 250);
            return;
        }

        const $input = $container.find('input.attribute-credit:visible');
        if (!$input.length) {
            log("'Credited as' input not found — retrying…");
            setTimeout(fillCreditedAsField, 250);
            return;
        }

        typeIntoReactInput($input[0], "drums", () => {
            log("'Credited as' field filled successfully.");
        });
    }

    /** MAIN: Create the custom button next to "Track relationships" */
    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        // Insert next to heading
        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        // Button click = open dialog
        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

#+begin_example
/** Fill the "Credited as" field */
function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    // The input is a normal text field
    const $input = $('input.attribute-credit:visible').last();
    if ($input.length) {
        const el = $input[0];
        el.focus();
        el.value = "drums"; // directly set value

        // trigger simple input event to notify any listeners
        const event = new Event('input', { bubbles: true, cancelable: true });
        el.dispatchEvent(event);

        log("'Credited as' field filled successfully.");
    } else {
        log("'Credited as' field not found yet — retrying…");
        setTimeout(fillCreditedAsField, 200);
    }
}
#+end_example

** lets start from here again

OK, lets start from here again. The following code works except filling in the "'Credited as' field:

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];

        // Create InputEvent without modifying el.value directly
        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });

        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}

function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

const $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit');
typeIntoReactInput($creditedInput[0], "drums", () => {
    console.log("'Credited as' field filled successfully.");
});
}

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

with the following console output

#+begin_example
[AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] AA: Injected custom button next to 'Track relationships'.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Custom button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Max Weinberg
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: drums (drum set)
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Button-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:176 'Credited as' field filled successfully.
#+end_example

** completely working version

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Button (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.5
// @description  Insert “Add instrument (React)” button, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, and Credited as fields.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    function fillRelationshipType() {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(fillRelationshipType, 250);
            return;
        }

        log("Found Relationship type field → typing 'instruments'");
        typeIntoAutocomplete($input, "instruments", fillArtistField);
    }

    // --- New sequence: Artist → Instrument → Credited as ---

    function fillArtistField() {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(fillArtistField, 250);
            return;
        }

        typeIntoAutocomplete($artist, "Max Weinberg", fillInstrumentField);
    }

    function fillInstrumentField() {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(fillInstrumentField, 250);
            return;
        }

        typeIntoAutocomplete($instr, "drums (drum set)", fillCreditedAsField);
    }

function typeIntoReactInput(el, text, callback) {
    el.focus({ preventScroll: true });
    let idx = 0;

    function typeNext() {
        if (idx >= text.length) {
            if (callback) callback();
            return;
        }

        const ch = text[idx];

        // Create InputEvent without modifying el.value directly
        const inputEvent = new InputEvent("input", {
            bubbles: true,
            cancelable: true,
            inputType: "insertText",
            data: ch,
        });

        el.dispatchEvent(inputEvent);

        idx++;
        setTimeout(typeNext, 50);
    }

    typeNext();
}

function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');
    if (!$creditedInput.length) {
        log("Credited-as input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    const text = "drums";

    // React-compliant setter
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
    if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

    // Dispatch events to notify React
    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));

    log("'Credited as' field filled successfully.");
}

    function createCustomButton() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButton, 500);
            return;
        }

        if ($('#aa-add-instrument').length) return;

        const $button = $('<button/>', {
            id: 'aa-add-instrument',
            text: "Add instrument (React)",
            style: `
                margin-left: 10px;
                background-color: #38a169;
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `
        });

        $heading.wrap('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.parent().append($button);

        log("AA: Injected custom button next to 'Track relationships'.");

        $button.on('click', () => {
            log("Custom button clicked → searching for batch-add button…");

            const tryBatchClick = () => {
                const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                if ($batch.length) {
                    log("Found batch-add button (exact class) → clicking.");
                    $batch[0].click();
                    setTimeout(fillRelationshipType, 300);
                    return true;
                }
                return false;
            };

            if (!tryBatchClick()) {
                log("Exact match failed — trying fallback text search…");

                const $fallback = $("button, a").filter((i, el) => {
                    const t = $(el).text().toLowerCase();
                    return t.includes("batch-add") && t.includes("record");
                });

                if ($fallback.length) {
                    log("Fallback batch-add button found → clicking.");
                    $fallback[0].click();
                    setTimeout(fillRelationshipType, 300);
                } else {
                    log("Batch-add button not found → logging all buttons/links.");
                    logAllButtonsAndLinks();
                }
            }
        });
    }

    $(document).ready(createCustomButton);

})();
#+end_example

Yes its working now. Can you now also emulate the final button press on the "Done" button

It's in the HTML code here

#+begin_example
  <div class="buttons" style="margin-top: 1em;">
    <button class="negative" type="button">Cancel
    </button>
    <div class="buttons-right">
      <button class="positive" type="button">Done
      </button>
    </div>
  </div>
#+end_example

#+begin_example
function fillCreditedAsField() {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');
    if (!$creditedInput.length) {
        log("Credited-as input not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
        return;
    }

    const el = $creditedInput[0];
    const text = "drums";

    // React-compliant setter
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
    if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

    // Dispatch events to notify React
    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));

    log("'Credited as' field filled successfully.");

    // Now click the Done button
    const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
    if ($doneButton.length) {
        log("Clicking Done button…");
        $doneButton[0].click();
    } else {
        log("Done button not found — retrying…");
        setTimeout(fillCreditedAsField, 250);
    }
}
#+end_example

** enhance

Now please rename the first button to "Max Weinberg" and add a second button named "Garry Tallent".
Refactor the code that in the case of the "Max Weinberg" button the following will be filled in (actually the same as before):

#+begin_example
"Max Weinberg" button:

Relationship type: "instruments"
Artist: "Max Weinberg"
Instrument: "drums (drum set)" Credited as: "drums"
#+end_example

and in the case of the "Garry Tallent" button the following (here the "Credited as" is really the empty string)

#+begin_example
"Garry Tallent" button:

Relationship type: "instruments"
Artist: "Garry Tallent"
Instrument: "electric bass guitar" Credited as: ""
#+end_example

Also prepare for future expansions to even more "Artist" buttons with the 'Relationship type: "instruments"'

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.7
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => fillInstrumentField(config));
    }

    function fillInstrumentField(config) {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(() => fillInstrumentField(config), 250);
            return;
        }

        typeIntoAutocomplete($instr, config.instrument, () => fillCreditedAsField(config));
    }

    function fillCreditedAsField(config) {
        log("Filling 'Credited as' field…");

        const $instrumentContainer = $('.multiselect.instrument').last();
        if (!$instrumentContainer.length) {
            log("Instrument container not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
            return;
        }

        const $creditedInput = $instrumentContainer.find('input.attribute-credit');
        if ($creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs;

            // React-compliant setter
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

            // Dispatch events to notify React
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        log("'Credited as' field filled successfully.");

        // Click the Done button
        const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
        if ($doneButton.length) {
            log("Clicking Done button…");
            $doneButton[0].click();
        } else {
            log("Done button not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
        }
    }

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const $button = $('<button/>', {
                text: config.label,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`"${config.label}" button clicked → searching for batch-add button…`);

                const tryBatchClick = () => {
                    const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                    if ($batch.length) {
                        log("Found batch-add button (exact class) → clicking.");
                        $batch[0].click();
                        setTimeout(() => fillFields(config), 300);
                        return true;
                    }
                    return false;
                };

                if (!tryBatchClick()) {
                    log("Exact match failed — trying fallback text search…");

                    const $fallback = $("button, a").filter((i, el) => {
                        const t = $(el).text().toLowerCase();
                        return t.includes("batch-add") && t.includes("record");
                    });

                    if ($fallback.length) {
                        log("Fallback batch-add button found → clicking.");
                        $fallback[0].click();
                        setTimeout(() => fillFields(config), 300);
                    } else {
                        log("Batch-add button not found → logging all buttons/links.");
                        logAllButtonsAndLinks();
                    }
                }
            });
        });

        log("AA: Injected custom artist buttons next to 'Track relationships'.");
    }

    $(document).ready(createCustomButtons);

})();
#+end_example


Well the two buttons show up, but there is an endless loop:

#+begin_example
[AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Heading 'Track relationships' not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] AA: Injected custom artist buttons next to 'Track relationships'.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] "Max Weinberg" button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Relationship type field not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Relationship type field not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Relationship type field not found yet — retrying…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22
#+end_example

** mult instruments working code

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.7
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => fillInstrumentField(config));
    }

    function fillInstrumentField(config) {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(() => fillInstrumentField(config), 250);
            return;
        }

        typeIntoAutocomplete($instr, config.instrument, () => fillCreditedAsField(config));
    }

    function fillCreditedAsField(config) {
        log("Filling 'Credited as' field…");

        const $instrumentContainer = $('.multiselect.instrument').last();
        if (!$instrumentContainer.length) {
            log("Instrument container not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
            return;
        }

        const $creditedInput = $instrumentContainer.find('input.attribute-credit');
        if ($creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs;

            // React-compliant setter
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

            // Dispatch events to notify React
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        log("'Credited as' field filled successfully.");

        // Click the Done button
        const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
        if ($doneButton.length) {
            log("Clicking Done button…");
            $doneButton[0].click();
        } else {
            log("Done button not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
        }
    }

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const $button = $('<button/>', {
                text: config.label,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

$button.on('click', () => {
    log(`"${config.label}" button clicked → searching for batch-add button…`);

    const tryBatchClick = () => {
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
        if ($batch.length) {
            log("Found batch-add button (exact class) → clicking.");
            $batch[0].click();

            // Wait a bit for the dialog to appear before filling fields
            setTimeout(() => fillFields(config), 500);
            return true;
        }
        return false;
    };

    if (!tryBatchClick()) {
        log("Exact match failed — trying fallback text search…");

        const $fallback = $("button, a").filter((i, el) => {
            const t = $(el).text().toLowerCase();
            return t.includes("batch-add") && t.includes("record");
        });

        if ($fallback.length) {
            log("Fallback batch-add button found → clicking.");
            $fallback[0].click();
            setTimeout(() => fillFields(config), 500);
        } else {
            log("Batch-add button not found → logging all buttons/links.");
            logAllButtonsAndLinks();
        }
    }
});
        });

        log("AA: Injected custom artist buttons next to 'Track relationships'.");
    }

    $(document).ready(createCustomButtons);

})();
#+end_example

adding loggig of "Credited as

#+begin_example
function fillCreditedAsField(config) {
    log("Filling 'Credited as' field…");

    const $instrumentContainer = $('.multiselect.instrument').last();
    if (!$instrumentContainer.length) {
        log("Instrument container not found — retrying…");
        setTimeout(() => fillCreditedAsField(config), 250);
        return;
    }

    const $creditedInput = $instrumentContainer.find('input.attribute-credit');

    typeIntoReactInput($creditedInput[0], config.creditedAs || "", () => {
        log(`'Credited as' field filled successfully → "${config.creditedAs || ""}"`);

        // Optional: click Done button automatically
        const $done = $("button.positive:visible").last();
        if ($done.length) {
            log("Clicking Done button…");
            $done[0].click();
        }
    });
}
#+end_example

** latest working version for multiple instruments

OK, lets start from here

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.7
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => fillInstrumentField(config));
    }

    function fillInstrumentField(config) {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(() => fillInstrumentField(config), 250);
            return;
        }

        typeIntoAutocomplete($instr, config.instrument, () => fillCreditedAsField(config));
    }

    function fillCreditedAsField(config) {
        log("Filling 'Credited as' field…");

        const $instrumentContainer = $('.multiselect.instrument').last();
        if (!$instrumentContainer.length) {
            log("Instrument container not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
            return;
        }

        const $creditedInput = $instrumentContainer.find('input.attribute-credit');
        if ($creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs;

            // React-compliant setter
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

            // Dispatch events to notify React
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        log(`'Credited as' field filled successfully with ${config.creditedAs}`);

        // Click the Done button
        const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
        if ($doneButton.length) {
            log("Clicking Done button…");
            $doneButton[0].click();
        } else {
            log("Done button not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
        }
    }

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const $button = $('<button/>', {
                text: config.label,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

$button.on('click', () => {
    log(`"${config.label}" button clicked → searching for batch-add button…`);

    const tryBatchClick = () => {
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
        if ($batch.length) {
            log("Found batch-add button (exact class) → clicking.");
            $batch[0].click();

            // Wait a bit for the dialog to appear before filling fields
            setTimeout(() => fillFields(config), 500);
            return true;
        }
        return false;
    };

    if (!tryBatchClick()) {
        log("Exact match failed — trying fallback text search…");

        const $fallback = $("button, a").filter((i, el) => {
            const t = $(el).text().toLowerCase();
            return t.includes("batch-add") && t.includes("record");
        });

        if ($fallback.length) {
            log("Fallback batch-add button found → clicking.");
            $fallback[0].click();
            setTimeout(() => fillFields(config), 500);
        } else {
            log("Batch-add button not found → logging all buttons/links.");
            logAllButtonsAndLinks();
        }
    }
});
        });

        log("AA: Injected custom artist buttons next to 'Track relationships'.");
    }

    $(document).ready(createCustomButtons);

})();
#+end_example

and make it more fool proof against timeouts, when pressing the buttons. Sometimes the data in the suggestion popup boxes is net yet there and we already emulated the "Return" button.
For example, it happend that "Garry Tallent" was entered as playing just instruments but not a specific one as the actual "electric bass guitar".


OK, lets start from here

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.7
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments", then Artist, Instrument, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => fillInstrumentField(config));
    }

    function fillInstrumentField(config) {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(() => fillInstrumentField(config), 250);
            return;
        }

        typeIntoAutocomplete($instr, config.instrument, () => fillCreditedAsField(config));
    }

    function fillCreditedAsField(config) {
        log("Filling 'Credited as' field…");

        const $instrumentContainer = $('.multiselect.instrument').last();
        if (!$instrumentContainer.length) {
            log("Instrument container not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
            return;
        }

        const $creditedInput = $instrumentContainer.find('input.attribute-credit');
        if ($creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs;

            // React-compliant setter
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

            // Dispatch events to notify React
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        log(`'Credited as' field filled successfully with ${config.creditedAs}`);

        // Click the Done button
        const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
        if ($doneButton.length) {
            log("Clicking Done button…");
            $doneButton[0].click();
        } else {
            log("Done button not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
        }
    }

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const $button = $('<button/>', {
                text: config.label,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

$button.on('click', () => {
    log(`"${config.label}" button clicked → searching for batch-add button…`);

    const tryBatchClick = () => {
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
        if ($batch.length) {
            log("Found batch-add button (exact class) → clicking.");
            $batch[0].click();

            // Wait a bit for the dialog to appear before filling fields
            setTimeout(() => fillFields(config), 500);
            return true;
        }
        return false;
    };

    if (!tryBatchClick()) {
        log("Exact match failed — trying fallback text search…");

        const $fallback = $("button, a").filter((i, el) => {
            const t = $(el).text().toLowerCase();
            return t.includes("batch-add") && t.includes("record");
        });

        if ($fallback.length) {
            log("Fallback batch-add button found → clicking.");
            $fallback[0].click();
            setTimeout(() => fillFields(config), 500);
        } else {
            log("Batch-add button not found → logging all buttons/links.");
            logAllButtonsAndLinks();
        }
    }
});
        });

        log("AA: Injected custom artist buttons next to 'Track relationships'.");
    }

    $(document).ready(createCustomButtons);

})();
#+end_example

and further refactor it to also add the "Relationship type" as "vocals" (instead of "instruments").

In the "vocals" case the "Instrument" field (where we before entered things like "drums (drum set)" or "electric bass
guitar") is instead now called "Vocal" and can have values like "lead vocals" or "spoken vocals" but also supports the
"Credited as" field.

The     'const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];'

    
structure should also support now the 'relationshipType: "vocal"' and for example 'vocal: "lead vocals"' like this

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg (i)",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent (i)",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        }
        {
            label: "Bruce Springsteen (v)",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

The Button text should have an "(i)" appended to the actual artist if his/here relationshipType is "instruments" and
"(v)" if it's "vocal"


#+begin_example
// ==UserScript==
// @name         AA - Add Instrument and Vocal Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.7
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments" or "vocals", then Artist, Instrument/Vocal, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument-vocal]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg (i)",  // (i) for instrument
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent (i)",  // (i) for instrument
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen (v)",  // (v) for vocals
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => {
            if (config.relationshipType === "instruments") {
                fillInstrumentField(config);
            } else if (config.relationshipType === "vocal") {
                fillVocalField(config);
            }
        });
    }

    function fillInstrumentField(config) {
        log("Filling Instrument field…");
        const $instr = $('input[placeholder="instrument"]:visible');

        if ($instr.length === 0) {
            log("Instrument field not ready — retrying…");
            setTimeout(() => fillInstrumentField(config), 250);
            return;
        }

        typeIntoAutocomplete($instr, config.instrument, () => fillCreditedAsField(config));
    }

    function fillVocalField(config) {
        log("Filling Vocal field…");
        const $vocal = $('input[placeholder="vocal"]:visible');

        if ($vocal.length === 0) {
            log("Vocal field not ready — retrying…");
            setTimeout(() => fillVocalField(config), 250);
            return;
        }

        typeIntoAutocomplete($vocal, config.vocal, () => fillCreditedAsField(config));
    }

    function fillCreditedAsField(config) {
        log("Filling 'Credited as' field…");

        const $instrumentContainer = $('.multiselect.instrument').last();
        const $vocalContainer = $('.multiselect.vocal').last();
        const $container = config.relationshipType === "instruments" ? $instrumentContainer : $vocalContainer;

        if (!$container.length) {
            log("Instrument/Vocal container not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
            return;
        }

        const $creditedInput = $container.find('input.attribute-credit');
        if ($creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs;

            // React-compliant setter
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

            // Dispatch events to notify React
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        log(`'Credited as' field filled successfully with ${config.creditedAs}`);

        // Click the Done button
        const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
        if ($doneButton.length) {
            log("Clicking Done button…");
            $doneButton[0].click();
        } else {
            log("Done button not found — retrying…");
            setTimeout(() => fillCreditedAsField(config), 250);
        }
    }

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const $button = $('<button/>', {
                text: config.label,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`"${config.label}" button clicked → searching for batch-add button…`);

                const tryBatchClick = ()
#+end_example


** working version for vocals and instruments with DONE button click

When using the following working userscript (the pressing the "DONE" button logic commented out), the scripts works
perfect.  But when including the "DONE" button click, the results are not OK. Especially the "Garry Tallent" button
doesn't fill in "electric bass guitar", or when pressing the "Bruce Springsteen" button, the "lead vocals" isn't filled
in.  It looks like a timing/timeout problem when accessing the value from the suggestion list.  Also when pressing all
the buttons right after each other, it looks like when the data for each butten gets entered in the "Instrument" or
"Vocal" field, the previously entered data is still present and the newly entered text is inserted somewhere in between.


#+begin_example
// ==UserScript==
// @name         AA - Add Instrument Buttons (React Release Editor) Extended
// @namespace    https://musicbrainz.org/
// @version      1.8
// @description  Insert multiple Artist buttons, open batch-add dialog, auto-fill relationship type = "instruments" or "vocals", then Artist, Instrument/Vocal, Credited as fields, and click Done.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        }
        // Add more artist buttons here easily
    ];

    function logAllButtonsAndLinks() {
        const elems = $('button, a');
        console.group('[AA] Fallback: Dumping all buttons/links (' + elems.length + ')');
        elems.each((i, el) => {
            console.group('Element #' + i);
            console.log('Text:', $(el).text().trim());
            console.log('Classes:', el.className);
            console.log('ID:', el.id);
            console.log('OuterHTML:', el.outerHTML);
            console.groupEnd();
        });
        console.groupEnd();
        alert("AA Script: Could NOT find the batch-add button.\n\nAll button/link elements have been logged in the console.");
    }

    function typeIntoAutocomplete($input, text, callback) {
        const el = $input[0];
        el.focus();

        let idx = 0;

        function reactInput(el, newValue) {
            const last = el.value;
            el.value = newValue;

            const e = new InputEvent("input", {
                bubbles: true,
                cancelable: true,
                inputType: "insertText",
                data: newValue.replace(last, "")
            });

            el.dispatchEvent(e);
        }

        function clickOptionMatching(prefix) {
            const $opt = $("li[role='option']").filter((i, el) =>
                $(el).text().trim().toLowerCase().startsWith(prefix.toLowerCase())
            );

            if ($opt.length) {
                log(`Clicking dropdown option: ${prefix}`);
                $opt[0].click();
                if (callback) callback();
            } else {
                log(`Dropdown option "${prefix}" not ready yet → retrying…`);
                setTimeout(() => clickOptionMatching(prefix), 100);
            }
        }

        function typeNext() {
            if (idx >= text.length) {
                setTimeout(() => clickOptionMatching(text), 150);
                return;
            }

            const ch = text[idx];
            const newValue = el.value + ch;
            reactInput(el, newValue);

            idx++;
            setTimeout(typeNext, 50);
        }

        typeNext();
    }

    // --- Main filling sequence ---
    function fillFields(config) {
        fillRelationshipType(config);
    }

    function fillRelationshipType(config) {
        log("Checking for Relationship Type input…");

        const $input = $('input.relationship-type:visible');

        if ($input.length === 0) {
            log("Relationship type field not found yet — retrying…");
            setTimeout(() => fillRelationshipType(config), 250);
            return;
        }

        log(`Found Relationship type field → typing '${config.relationshipType}'`);
        typeIntoAutocomplete($input, config.relationshipType, () => fillArtistField(config));
    }

    function fillArtistField(config) {
        log("Filling Artist field…");
        const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

        if ($artist.length === 0) {
            log("Artist field not ready — retrying…");
            setTimeout(() => fillArtistField(config), 250);
            return;
        }

        typeIntoAutocomplete($artist, config.artist, () => fillInstrumentOrVocalField(config));
    }

    function fillInstrumentOrVocalField(config) {
        log(config.relationshipType === "instruments" ? "Filling Instrument field…" : "Filling Vocal field…");

        const $inputField = $('input[placeholder="' + (config.relationshipType === "instruments" ? "instrument" : "vocal") + '"]:visible');

        if ($inputField.length === 0) {
            log(`${config.relationshipType === "instruments" ? "Instrument" : "Vocal"} field not ready — retrying…`);
            setTimeout(() => fillInstrumentOrVocalField(config), 250);
            return;
        }

        const valueToEnter = config.relationshipType === "instruments" ? config.instrument : config.vocal;
        typeIntoAutocomplete($inputField, valueToEnter, () => fillCreditedAsField(config));
    }

function fillCreditedAsField(config) {
    log("Filling 'Credited as' field…");

    // Check if the relationship is for vocals or instruments and target the appropriate container
    let $container;
    if (config.relationshipType === "instruments") {
        $container = $('.multiselect.instrument').last(); // For instruments
    } else if (config.relationshipType === "vocal") {
        $container = $('.multiselect.vocal').last(); // For vocals (new selector)
    }

    if (!$container.length) {
        log(`${config.relationshipType === "instruments" ? "Instrument" : "Vocal"} container not found — retrying…`);
        setTimeout(() => fillCreditedAsField(config), 250);
        return;
    }

    const $creditedInput = $container.find('input.attribute-credit');
    if ($creditedInput.length) {
        const el = $creditedInput[0];
        const text = config.creditedAs;

        // React-compliant setter
        const nativeInputValueSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
        if (nativeInputValueSetter) nativeInputValueSetter.call(el, text);

        // Dispatch events to notify React
        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
    }

    log(`'Credited as' field filled successfully with ${config.creditedAs}`);

    // Click the Done button
    // const $doneButton = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");
    // if ($doneButton.length) {
    //     log("Clicking Done button…");
    //     $doneButton[0].click();
    // } else {
    //     log("Done button not found — retrying…");
    //     setTimeout(() => fillCreditedAsField(config), 250);
    // }
}

    // --- Button creation ---
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            const buttonText = config.relationshipType === "instruments" ? `${config.label} (i)` : `${config.label} (v)`;

            const $button = $('<button/>', {
                text: buttonText,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`"${config.label}" button clicked → searching for batch-add button…`);

                const tryBatchClick = () => {
                    const $batch = $("button.add-item.with-label.batch-add-recording-relationship");
                    if ($batch.length) {
                        log("Found batch-add button (exact class) → clicking.");
                        $batch[0].click();

                        // Wait a bit for the dialog to appear before filling fields
                        setTimeout(() => fillFields(config), 500);
                        return true;
                    }
                    return false;
                };

                if (!tryBatchClick()) {
                    log("Exact match failed — trying fallback text search…");

                    const $fallback = $("button, a").filter((i, el) => {
                        const t = $(el).text().toLowerCase();
                        return t.includes("batch-add") && t.includes("record");
                    });

                    if ($fallback.length) {
                        log("Fallback batch-add button found → clicking.");
                        $fallback[0].click();
                        setTimeout(() => fillFields(config), 500);
                    } else {
                        log("Batch-add button not found → logging all buttons/links.");
                        logAllButtonsAndLinks();
                    }
                }
            });
        });

        log("AA: Injected custom buttons.");
    }

    // Wait for the page to load, then create the custom buttons
    setTimeout(createCustomButtons, 1000);
})();
#+end_example


#+begin_example
[AA-add-instrument] AA: Injected custom buttons.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] "Max Weinberg" button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Max Weinberg
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: drums (drum set)
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled successfully with drums
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] "Garry Tallent" button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'instruments'
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: instruments
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Garry Tallent
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Instrument field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: electric bass guitar
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled successfully with 
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] "Bruce Springsteen" button clicked → searching for batch-add button…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found batch-add button (exact class) → clicking.
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Checking for Relationship Type input…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Found Relationship type field → typing 'vocal'
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: vocal
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Artist field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: Bruce Springsteen
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling Vocal field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Clicking dropdown option: lead vocals
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] Filling 'Credited as' field…
userscript.html?name=AA-Add-Instrument-Buttons-React-Release-Editor-Extended.user.js&id=685ef80c-cb44-4a9c-a75b-1a985d1501c8:22 [AA-add-instrument] 'Credited as' field filled successfully with 
#+end_example


#+begin_example
// ==UserScript==
// @name         AA - Add Instrument/Vocal Buttons (React Release Editor) Robust
// @namespace    https://musicbrainz.org/
// @version      1.9
// @description  Robust: Insert artist buttons, open batch-add dialog, reliably fill relationship type (instruments|vocal), artist, instrument/vocal, credited-as, click Done — sequential queue + dialog lifecycle awareness.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        }
        // Add/remove entries as needed
    ];

    // ----------------- Utilities -----------------
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // Wait for an element matching selector that is visible
    async function waitVisible(selector, opts = {}) {
        const timeout = opts.timeout ?? 5000;
        const interval = opts.interval ?? 100;
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const $el = $(selector).filter(':visible');
            if ($el.length) return $el;
            await sleep(interval);
        }
        return null;
    }

    // Wait until no visible dialog exists (used to ensure previous dialog fully closed)
    async function waitDialogClosed(timeout = 3000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            // adjust selector if your dialog uses a specific class; generic attempt:
            const $visibleDialogs = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            if ($visibleDialogs.length === 0) {
                // small extra breathing room so React finishes unmount
                await sleep(200);
                return true;
            }
            await sleep(100);
        }
        return false;
    }

    // Wait until a particular condition returns truthy or times out
    async function waitForCondition(conditionFn, {timeout = 3000, interval = 100} = {}) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            try {
                if (await conditionFn()) return true;
            } catch (e) { /* ignore */ }
            await sleep(interval);
        }
        return false;
    }

    // Set value for React-controlled input and dispatch events
    function setReactValueAndDispatch(el, value) {
        try {
            const nativeSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeSetter) nativeSetter.call(el, value);
            else el.value = value;

            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            // some react versions also respond to these:
            el.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } catch (e) {
            // fallback
            el.value = value;
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    // Clear an input cleanly (React-aware)
    function clearInput(el) {
        setReactValueAndDispatch(el, '');
    }

    // Type into autocomplete input character by character and select matching option when available.
    // This function is defensive: it waits for suggestion list, waits for an option starting with prefix (case-insensitive),
    // clicks it, then waits until some sign of selection appears (or a small delay).
    async function typeAndSelect($input, text, {charDelay = 40, postSelectWait = 300, optionSelector = "li[role='option']"} = {}) {
        const el = $input[0];
        if (!el) throw new Error('Input element missing');

        el.focus();

        // Ensure input is empty first (React-friendly)
        clearInput(el);
        await sleep(50);

        // Type characters slowly
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const newValue = el.value + ch;
            setReactValueAndDispatch(el, newValue);
            await sleep(charDelay);
        }

        // At end, give suggestions a moment
        await sleep(120);

        // Wait for a suggestion that startsWith text
        const found = await waitForCondition(() => {
            const $opts = $(optionSelector).filter(':visible');
            if (!$opts.length) return false;
            // prefer exact startsWith (case-insensitive)
            const match = $opts.toArray().find(o => $(o).text().trim().toLowerCase().startsWith(text.toLowerCase()));
            if (match) {
                match.click();
                return true;
            }
            // fallback: any option that includes the text
            const match2 = $opts.toArray().find(o => $(o).text().trim().toLowerCase().includes(text.toLowerCase()));
            if (match2) {
                match2.click();
                return true;
            }
            return false;
        }, {timeout: 3000, interval: 120});

        if (!found) {
            log(`Warning: option for "${text}" not found in suggestions after timeout.`);
        }

        // give React time to update internal state / tokens
        await sleep(postSelectWait);
    }

    // Reliable method: click batch-add button but only AFTER ensuring previous dialog closed
    async function openBatchAddDialog() {
        // Ensure previous closed
        await waitDialogClosed(2000);

        // Find the batch button
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship, button.add-item.batch-add-recording-relationship, button.add-item.with-label").filter(function() {
            const t = $(this).text().toLowerCase();
            return t.includes('batch-add') || t.includes('batch add') || (t.includes('add') && t.includes('record'));
        });

        if ($batch.length === 0) {
            log("Batch-add button not found via selectors");
            return false;
        }

        // Click it
        $batch[0].click();

        // Wait for dialog to appear
        const appeared = await waitForCondition(() => {
            const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            return $d.length > 0;
        }, {timeout: 3000, interval: 100});

        if (!appeared) {
            // give one more small delay
            await sleep(400);
        }

        // Extra safety pause so React finishes mounting
        await sleep(300);
        return true;
    }

    // ----------------- Filling sequence (async) -----------------
    async function fillFieldsAsync(config) {
        log(`Start filling for: ${config.label} (${config.relationshipType})`);

        // 1) Relationship type
        const $relInput = await waitVisible('input.relationship-type', {timeout: 4000});
        if (!$relInput) {
            log("Relationship type input not found — aborting this item.");
            return false;
        }
        log(`Typing relationshipType '${config.relationshipType}'`);
        await typeAndSelect($relInput, config.relationshipType, {charDelay: 40, postSelectWait: 200});

        // 2) Artist
        const $artist = await waitVisible('input[placeholder="Type to search, or paste an MBID"]', {timeout: 4000});
        if (!$artist) {
            log("Artist input not found — aborting this item.");
            return false;
        }
        log(`Typing artist '${config.artist}'`);
        await typeAndSelect($artist, config.artist, {charDelay: 50, postSelectWait: 250});

        // 3) Instrument or Vocal
        const placeholderName = config.relationshipType === 'instruments' ? 'instrument' : 'vocal';
        const $inst = await waitVisible(`input[placeholder="${placeholderName}"]`, {timeout: 4000});
        if (!$inst) {
            log(`${placeholderName} input not found — aborting this item.`);
            return false;
        }
        const desired = (config.relationshipType === 'instruments') ? config.instrument : config.vocal;
        if (desired && desired.length > 0) {
            log(`Typing ${placeholderName} '${desired}'`);
            await typeAndSelect($inst, desired, {charDelay: 45, postSelectWait: 300});
        } else {
            log(`No ${placeholderName} value provided, skipping selection.`);
        }

        // 4) Credited as: find correct container near the instrument/vocal input
        log("Attempting to fill 'Credited as' field…");
        // Strategy: find the nearest .multiselect that contains an input.attribute-credit or the 'attribute-credit' input visible.
        // We'll search visible attribute-credit inputs first, and then try to ensure it's the correct one by proximity.
        let $creditedInput = $('.attribute-credit:visible');
        if ($creditedInput.length === 0) {
            // fallback: look for input.attribute-credit anywhere inside visible multiselects
            const $multi = $('.multiselect:visible').filter(function() {
                return $(this).find('input[placeholder]').length > 0;
            }).last();
            if ($multi && $multi.length) {
                $creditedInput = $multi.find('input.attribute-credit:visible');
            }
        }

        // Another proximity attempt: find attribute-credit inside last visible .multiselect.* that also contains the placeholder input
        if ($creditedInput.length === 0) {
            const $lastMulti = $('.multiselect:visible').filter((i, el) => {
                return $(el).find(`input[placeholder="${placeholderName}"]`).length > 0;
            }).last();
            if ($lastMulti && $lastMulti.length) {
                $creditedInput = $lastMulti.find('input.attribute-credit:visible');
            }
        }

        // If still not found, try common selector: .multiselect.instrument or .multiselect.vocal
        if ($creditedInput.length === 0) {
            if (config.relationshipType === 'instruments') {
                $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit:visible');
            } else {
                $creditedInput = $('.multiselect.vocal').last().find('input.attribute-credit:visible');
            }
        }

        // Final fallback: any visible input whose name/id contains 'credit'
        if ($creditedInput.length === 0) {
            $creditedInput = $("input:visible").filter((i, el) => {
                const idn = (el.id || '').toLowerCase();
                const name = (el.name || '').toLowerCase();
                const cls = (el.className || '').toLowerCase();
                return idn.includes('credit') || name.includes('credit') || cls.includes('attribute-credit');
            }).first();
        }

        if ($creditedInput && $creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs ?? '';
            // set and dispatch react-friendly events
            setReactValueAndDispatch(el, text);
            // give React a little time
            await sleep(120);
            log(`'Credited as' set to "${text}"`);
        } else {
            log("Could not find credited-as input (it's optional); continuing.");
        }

        // 5) Click Done, but wait until Done appears and is stable
        const $doneButton = await waitVisible('button.positive:visible', {timeout: 4000});
        if ($doneButton) {
            // ensure the button text is exactly "Done" (there may be other positive buttons)
            const $exactDone = $doneButton.filter((i, btn) => $(btn).text().trim() === 'Done');
            if ($exactDone.length) {
                log("Clicking Done");
                $exactDone[0].click();
                // Wait until dialog disappears
                await waitForCondition(() => {
                    const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
                    return $d.length === 0;
                }, {timeout: 3500, interval: 120});
                // small extra breathing room
                await sleep(250);
                log(`Finished item: ${config.label}`);
                return true;
            } else {
                log("Done button not found among positive buttons — skipping Done.");
                return true;
            }
        } else {
            log("Done button not found (timeout) — skipping Done.");
            return true;
        }
    }

    // ----------------- Queue to process clicks sequentially -----------------
    const queue = [];
    let processing = false;

    async function processQueue() {
        if (processing) return;
        processing = true;
        while (queue.length) {
            const config = queue.shift();
            try {
                log(`Processing queue item: ${config.label}`);
                // Open dialog (ensures previous is closed and waits until the dialog is stable)
                const opened = await openBatchAddDialog();
                if (!opened) {
                    log("Could not open batch-add dialog — skipping this item.");
                    await sleep(300);
                    continue;
                }

                // Fill all fields and click Done
                await fillFieldsAsync(config);

                // Give small pause before next item to let React settle
                await sleep(300);
            } catch (e) {
                console.error('[AA-add-instrument] Error processing item', e);
                // tiny pause and continue with next item
                await sleep(500);
            }
        }
        processing = false;
    }

    // ----------------- UI: create buttons -----------------
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            // Append (i) or (v) to button label UI
            const suffix = config.relationshipType === 'instruments' ? ' (i)' : (config.relationshipType === 'vocal' ? ' (v)' : '');
            const buttonText = `${config.label}${suffix}`;

            const $button = $('<button/>', {
                text: buttonText,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`Enqueued "${config.label}" (${config.relationshipType})`);
                // push a shallow copy to avoid mutation issues
                queue.push(Object.assign({}, config));
                processQueue().catch(e => console.error(e));
            });
        });

        log("AA: Injected custom buttons.");
    }

    // Start
    $(document).ready(() => {
        // Wait a bit to ensure page ready
        setTimeout(createCustomButtons, 700);
    });

})();
#+end_example


Notes & rationale (quick)

Sequential queue: pressing multiple buttons rapidly will enqueue the tasks and process them one-by-one. This prevents DOM/React racing between dialogs.

Wait for dialog lifecycle: we wait for dialogs to be closed before opening a new one and wait for them to mount before interacting.

Typing + selection: types char-by-char and only clicks suggestion options after they appear. If the suggestion isn't present, it logs a warning and continues (no accidental Return/enter).

React-friendly input setting: uses native property setter + input/change events so React sees the updates.

Credited-as resolution: multiple strategies to locate the correct credited-as input — proximity search, .multiselect.*, and fallback name/class heuristics.

If you want, I can:

tweak timing constants (charDelay, waits) for your machine/network,

make the queue visible with an on-page status indicator,

add a per-button per-field override for custom timeouts,

or adapt selectors if your MusicBrainz theme uses different class names.

Want me to adjust timing to be even more conservative (safer) or more aggressive (faster)?

** most robust version so far

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument/Vocal Buttons (React Release Editor) Robust
// @namespace    https://musicbrainz.org/
// @version      1.9
// @description  Robust: Insert artist buttons, open batch-add dialog, reliably fill relationship type (instruments|vocal), artist, instrument/vocal, credited-as, click Done — sequential queue + dialog lifecycle awareness.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        }
        // Add/remove entries as needed
    ];

    // ----------------- Utilities -----------------
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // Wait for an element matching selector that is visible
    async function waitVisible(selector, opts = {}) {
        const timeout = opts.timeout ?? 5000;
        const interval = opts.interval ?? 100;
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const $el = $(selector).filter(':visible');
            if ($el.length) return $el;
            await sleep(interval);
        }
        return null;
    }

    // Wait until no visible dialog exists (used to ensure previous dialog fully closed)
    async function waitDialogClosed(timeout = 3000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            // adjust selector if your dialog uses a specific class; generic attempt:
            const $visibleDialogs = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            if ($visibleDialogs.length === 0) {
                // small extra breathing room so React finishes unmount
                await sleep(200);
                return true;
            }
            await sleep(100);
        }
        return false;
    }

    // Wait until a particular condition returns truthy or times out
    async function waitForCondition(conditionFn, {timeout = 3000, interval = 100} = {}) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            try {
                if (await conditionFn()) return true;
            } catch (e) { /* ignore */ }
            await sleep(interval);
        }
        return false;
    }

    // Set value for React-controlled input and dispatch events
    function setReactValueAndDispatch(el, value) {
        try {
            const nativeSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeSetter) nativeSetter.call(el, value);
            else el.value = value;

            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            // some react versions also respond to these:
            el.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } catch (e) {
            // fallback
            el.value = value;
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    // Clear an input cleanly (React-aware)
    function clearInput(el) {
        setReactValueAndDispatch(el, '');
    }

    // Type into autocomplete input character by character and select matching option when available.
    // This function is defensive: it waits for suggestion list, waits for an option starting with prefix (case-insensitive),
    // clicks it, then waits until some sign of selection appears (or a small delay).
    async function typeAndSelect($input, text, {charDelay = 40, postSelectWait = 300, optionSelector = "li[role='option']"} = {}) {
        const el = $input[0];
        if (!el) throw new Error('Input element missing');

        el.focus();

        // Ensure input is empty first (React-friendly)
        clearInput(el);
        await sleep(50);

        // Type characters slowly
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const newValue = el.value + ch;
            setReactValueAndDispatch(el, newValue);
            await sleep(charDelay);
        }

        // At end, give suggestions a moment
        await sleep(120);

        // Wait for a suggestion that startsWith text
        const found = await waitForCondition(() => {
            const $opts = $(optionSelector).filter(':visible');
            if (!$opts.length) return false;
            // prefer exact startsWith (case-insensitive)
            const match = $opts.toArray().find(o => $(o).text().trim().toLowerCase().startsWith(text.toLowerCase()));
            if (match) {
                match.click();
                return true;
            }
            // fallback: any option that includes the text
            const match2 = $opts.toArray().find(o => $(o).text().trim().toLowerCase().includes(text.toLowerCase()));
            if (match2) {
                match2.click();
                return true;
            }
            return false;
        }, {timeout: 3000, interval: 120});

        if (!found) {
            log(`Warning: option for "${text}" not found in suggestions after timeout.`);
        }

        // give React time to update internal state / tokens
        await sleep(postSelectWait);
    }

    // Reliable method: click batch-add button but only AFTER ensuring previous dialog closed
    async function openBatchAddDialog() {
        // Ensure previous closed
        await waitDialogClosed(2000);

        // Find the batch button
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship, button.add-item.batch-add-recording-relationship, button.add-item.with-label").filter(function() {
            const t = $(this).text().toLowerCase();
            return t.includes('batch-add') || t.includes('batch add') || (t.includes('add') && t.includes('record'));
        });

        if ($batch.length === 0) {
            log("Batch-add button not found via selectors");
            return false;
        }

        // Click it
        $batch[0].click();

        // Wait for dialog to appear
        const appeared = await waitForCondition(() => {
            const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            return $d.length > 0;
        }, {timeout: 3000, interval: 100});

        if (!appeared) {
            // give one more small delay
            await sleep(400);
        }

        // Extra safety pause so React finishes mounting
        await sleep(300);
        return true;
    }

    // ----------------- Filling sequence (async) -----------------
    async function fillFieldsAsync(config) {
        log(`Start filling for: ${config.label} (${config.relationshipType})`);

        // 1) Relationship type
        const $relInput = await waitVisible('input.relationship-type', {timeout: 4000});
        if (!$relInput) {
            log("Relationship type input not found — aborting this item.");
            return false;
        }
        log(`Typing relationshipType '${config.relationshipType}'`);
        await typeAndSelect($relInput, config.relationshipType, {charDelay: 40, postSelectWait: 200});

        // 2) Artist
        const $artist = await waitVisible('input[placeholder="Type to search, or paste an MBID"]', {timeout: 4000});
        if (!$artist) {
            log("Artist input not found — aborting this item.");
            return false;
        }
        log(`Typing artist '${config.artist}'`);
        await typeAndSelect($artist, config.artist, {charDelay: 50, postSelectWait: 250});

        // 3) Instrument or Vocal
        const placeholderName = config.relationshipType === 'instruments' ? 'instrument' : 'vocal';
        const $inst = await waitVisible(`input[placeholder="${placeholderName}"]`, {timeout: 4000});
        if (!$inst) {
            log(`${placeholderName} input not found — aborting this item.`);
            return false;
        }
        const desired = (config.relationshipType === 'instruments') ? config.instrument : config.vocal;
        if (desired && desired.length > 0) {
            log(`Typing ${placeholderName} '${desired}'`);
            await typeAndSelect($inst, desired, {charDelay: 45, postSelectWait: 300});
        } else {
            log(`No ${placeholderName} value provided, skipping selection.`);
        }

        // 4) Credited as: find correct container near the instrument/vocal input
        log("Attempting to fill 'Credited as' field…");
        // Strategy: find the nearest .multiselect that contains an input.attribute-credit or the 'attribute-credit' input visible.
        // We'll search visible attribute-credit inputs first, and then try to ensure it's the correct one by proximity.
        let $creditedInput = $('.attribute-credit:visible');
        if ($creditedInput.length === 0) {
            // fallback: look for input.attribute-credit anywhere inside visible multiselects
            const $multi = $('.multiselect:visible').filter(function() {
                return $(this).find('input[placeholder]').length > 0;
            }).last();
            if ($multi && $multi.length) {
                $creditedInput = $multi.find('input.attribute-credit:visible');
            }
        }

        // Another proximity attempt: find attribute-credit inside last visible .multiselect.* that also contains the placeholder input
        if ($creditedInput.length === 0) {
            const $lastMulti = $('.multiselect:visible').filter((i, el) => {
                return $(el).find(`input[placeholder="${placeholderName}"]`).length > 0;
            }).last();
            if ($lastMulti && $lastMulti.length) {
                $creditedInput = $lastMulti.find('input.attribute-credit:visible');
            }
        }

        // If still not found, try common selector: .multiselect.instrument or .multiselect.vocal
        if ($creditedInput.length === 0) {
            if (config.relationshipType === 'instruments') {
                $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit:visible');
            } else {
                $creditedInput = $('.multiselect.vocal').last().find('input.attribute-credit:visible');
            }
        }

        // Final fallback: any visible input whose name/id contains 'credit'
        if ($creditedInput.length === 0) {
            $creditedInput = $("input:visible").filter((i, el) => {
                const idn = (el.id || '').toLowerCase();
                const name = (el.name || '').toLowerCase();
                const cls = (el.className || '').toLowerCase();
                return idn.includes('credit') || name.includes('credit') || cls.includes('attribute-credit');
            }).first();
        }

        if ($creditedInput && $creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs ?? '';
            // set and dispatch react-friendly events
            setReactValueAndDispatch(el, text);
            // give React a little time
            await sleep(120);
            log(`'Credited as' set to "${text}"`);
        } else {
            log("Could not find credited-as input (it's optional); continuing.");
        }

        // 5) Click Done, but wait until Done appears and is stable
        const $doneButton = await waitVisible('button.positive:visible', {timeout: 4000});
        if ($doneButton) {
            // ensure the button text is exactly "Done" (there may be other positive buttons)
            const $exactDone = $doneButton.filter((i, btn) => $(btn).text().trim() === 'Done');
            if ($exactDone.length) {
                log("Clicking Done");
                $exactDone[0].click();
                // Wait until dialog disappears
                await waitForCondition(() => {
                    const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
                    return $d.length === 0;
                }, {timeout: 3500, interval: 120});
                // small extra breathing room
                await sleep(250);
                log(`Finished item: ${config.label}`);
                return true;
            } else {
                log("Done button not found among positive buttons — skipping Done.");
                return true;
            }
        } else {
            log("Done button not found (timeout) — skipping Done.");
            return true;
        }
    }

    // ----------------- Queue to process clicks sequentially -----------------
    const queue = [];
    let processing = false;

    async function processQueue() {
        if (processing) return;
        processing = true;
        while (queue.length) {
            const config = queue.shift();
            try {
                log(`Processing queue item: ${config.label}`);
                // Open dialog (ensures previous is closed and waits until the dialog is stable)
                const opened = await openBatchAddDialog();
                if (!opened) {
                    log("Could not open batch-add dialog — skipping this item.");
                    await sleep(300);
                    continue;
                }

                // Fill all fields and click Done
                await fillFieldsAsync(config);

                // Give small pause before next item to let React settle
                await sleep(300);
            } catch (e) {
                console.error('[AA-add-instrument] Error processing item', e);
                // tiny pause and continue with next item
                await sleep(500);
            }
        }
        processing = false;
    }

    // ----------------- UI: create buttons -----------------
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            // Append (i) or (v) to button label UI
            const suffix = config.relationshipType === 'instruments' ? ' (i)' : (config.relationshipType === 'vocal' ? ' (v)' : '');
            const buttonText = `${config.label}${suffix}`;

            const $button = $('<button/>', {
                text: buttonText,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`Enqueued "${config.label}" (${config.relationshipType})`);
                // push a shallow copy to avoid mutation issues
                queue.push(Object.assign({}, config));
                processQueue().catch(e => console.error(e));
            });
        });

        log("AA: Injected custom buttons.");
    }

    // Start
    $(document).ready(() => {
        // Wait a bit to ensure page ready
        setTimeout(createCustomButtons, 700);
    });

})();
#+end_example

** add performer

Please add also support for the following ARTIST_BUTTON with 'relationshipType: "performed / performer"':

#+begin_example
        {
            label: "E Street Band",
            relationshipType: "performed / performer",
            artist: "The E Street Band"
        }
#+end_example

The 'relationshipType: "performed / performer"' doesn't have any other input type like "instrument with creditdAs" or
"vocal with creditedAs", so after entering the actual 'relationshipType: "performed / performer"' and the corresponding
artist, the DONE button should be clicked right away.

so in the code it should look like:

#+begin_example
    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        },
        {
            label: "Street Band",
            relationshipType: "performed / performer",
            artist: "The E Street Band"
        }
        // Add/remove entries as needed
    ];

#+end_example


# Antwort

#+begin_example
const ARTIST_BUTTONS = [
    {
        label: "Max Weinberg",
        relationshipType: "instruments",
        artist: "Max Weinberg",
        instrument: "drums (drum set)",
        creditedAs: "drums"
    },
    {
        label: "Garry Tallent",
        relationshipType: "instruments",
        artist: "Garry Tallent",
        instrument: "electric bass guitar",
        creditedAs: ""
    },
    {
        label: "Bruce Springsteen",
        relationshipType: "vocal",
        artist: "Bruce Springsteen",
        vocal: "lead vocals",
        creditedAs: ""
    },
    {
        label: "E Street Band",
        relationshipType: "performed / performer",
        artist: "The E Street Band"
    }
];
#+end_example

Replace your current fillFields() with this:

#+begin_example
function fillFields(config) {
    if (config.relationshipType === "performed / performer") {
        fillPerformerRelationship(config);
    } else {
        fillRelationshipType(config); // instruments + vocal
    }
}
#+end_example

Add this new function right below your other fill functions:

#+begin_example
function fillPerformerRelationship(config) {
    log("Performer mode: filling relationship type…");

    const $input = $('input.relationship-type:visible');

    if ($input.length === 0) {
        log("Performer: relationship type field not ready — retrying…");
        setTimeout(() => fillPerformerRelationship(config), 200);
        return;
    }

    typeIntoAutocomplete($input, config.relationshipType, () => {
        log("Performer mode: filling Artist…");
        setTimeout(() => fillPerformerArtist(config), 200);
    });
}

function fillPerformerArtist(config) {
    const $artist = $('input[placeholder="Type to search, or paste an MBID"]:visible');

    if ($artist.length === 0) {
        log("Performer: Artist field not ready — retrying…");
        setTimeout(() => fillPerformerArtist(config), 200);
        return;
    }

    typeIntoAutocomplete($artist, config.artist, () => {
        log("Performer: Artist filled → clicking Done…");
        clickDoneButton();
    });
}

function clickDoneButton() {
    const $done = $('button.positive:visible').filter((i, btn) => $(btn).text().trim() === "Done");

    if ($done.length) {
        log("Clicking Done button for performer relationship…");
        $done[0].click();
    } else {
        log("Done button not found — retrying…");
        setTimeout(clickDoneButton, 200);
    }
}
#+end_example

(to mark performer buttons with (p) instead of (i) or (v))
Replace the button label generation with this version:

#+begin_example
const typeLabel =
    config.relationshipType === "instruments" ? "(i)" :
    config.relationshipType === "vocal" ? "(v)" :
    "(p)"; // performer

const buttonText = `${config.label} ${typeLabel}`;
#+end_example

If you want, I can:

✅ merge everything into a single unified script
✅ add automatic queuing for batch multi-button presses
✅ add support for multiple performer roles
✅ add color-coding or icons for button types
✅ add better error handling / logging panel
Add keyboard shortcuts for buttons

Just tell me!

** lets see

Please add color-coding and icons for button types and keyboard shortcuts for buttons but do not change any other
aspects of the following code (nothing else should be rewritten, no comments removed or changed)

#+begin_example
// ==UserScript==
// @name         AA - Add Instrument/Vocal Buttons (React Release Editor) Robust + Performer
// @namespace    https://musicbrainz.org/
// @version      1.10
// @description  Robust: Insert artist buttons, open batch-add dialog, reliably fill relationship type (instruments|vocal|performed / performer), artist, instrument/vocal, credited-as, click Done — sequential queue + dialog lifecycle awareness.
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        },
        {
            label: "E Street Band",
            relationshipType: "performed / performer",
            artist: "The E Street Band"
        }
        // Add/remove entries as needed
    ];

    // ----------------- Utilities -----------------
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // Wait for an element matching selector that is visible
    async function waitVisible(selector, opts = {}) {
        const timeout = opts.timeout ?? 5000;
        const interval = opts.interval ?? 100;
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const $el = $(selector).filter(':visible');
            if ($el.length) return $el;
            await sleep(interval);
        }
        return null;
    }

    // Wait until no visible dialog exists (used to ensure previous dialog fully closed)
    async function waitDialogClosed(timeout = 3000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            // adjust selector if your dialog uses a specific class; generic attempt:
            const $visibleDialogs = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            if ($visibleDialogs.length === 0) {
                // small extra breathing room so React finishes unmount
                await sleep(200);
                return true;
            }
            await sleep(100);
        }
        return false;
    }

    // Wait until a particular condition returns truthy or times out
    async function waitForCondition(conditionFn, {timeout = 3000, interval = 100} = {}) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            try {
                if (await conditionFn()) return true;
            } catch (e) { /* ignore */ }
            await sleep(interval);
        }
        return false;
    }

    // Set value for React-controlled input and dispatch events
    function setReactValueAndDispatch(el, value) {
        try {
            const nativeSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeSetter) nativeSetter.call(el, value);
            else el.value = value;

            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            // some react versions also respond to these:
            el.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } catch (e) {
            // fallback
            el.value = value;
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    // Clear an input cleanly (React-aware)
    function clearInput(el) {
        setReactValueAndDispatch(el, '');
    }

    // Type into autocomplete input character by character and select matching option when available.
    // This function is defensive: it waits for suggestion list, waits for an option starting with prefix (case-insensitive),
    // clicks it, then waits until some sign of selection appears (or a small delay).
    async function typeAndSelect($input, text, {charDelay = 40, postSelectWait = 300, optionSelector = "li[role='option']"} = {}) {
        const el = $input[0];
        if (!el) throw new Error('Input element missing');

        el.focus();

        // Ensure input is empty first (React-friendly)
        clearInput(el);
        await sleep(50);

        // Type characters slowly
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const newValue = el.value + ch;
            setReactValueAndDispatch(el, newValue);
            await sleep(charDelay);
        }

        // At end, give suggestions a moment
        await sleep(120);

        // Wait for a suggestion that startsWith text
        const found = await waitForCondition(() => {
            const $opts = $(optionSelector).filter(':visible');
            if (!$opts.length) return false;
            // prefer exact startsWith (case-insensitive)
            const match = $opts.toArray().find(o => $(o).text().trim().toLowerCase().startsWith(text.toLowerCase()));
            if (match) {
                match.click();
                return true;
            }
            // fallback: any option that includes the text
            const match2 = $opts.toArray().find(o => $(o).text().trim().toLowerCase().includes(text.toLowerCase()));
            if (match2) {
                match2.click();
                return true;
            }
            return false;
        }, {timeout: 3000, interval: 120});

        if (!found) {
            log(`Warning: option for "${text}" not found in suggestions after timeout.`);
        }

        // give React time to update internal state / tokens
        await sleep(postSelectWait);
    }

    // Reliable method: click batch-add button but only AFTER ensuring previous dialog closed
    async function openBatchAddDialog() {
        // Ensure previous closed
        await waitDialogClosed(2000);

        // Find the batch button
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship, button.add-item.batch-add-recording-relationship, button.add-item.with-label").filter(function() {
            const t = $(this).text().toLowerCase();
            return t.includes('batch-add') || t.includes('batch add') || (t.includes('add') && t.includes('record'));
        });

        if ($batch.length === 0) {
            log("Batch-add button not found via selectors");
            return false;
        }

        // Click it
        $batch[0].click();

        // Wait for dialog to appear
        const appeared = await waitForCondition(() => {
            const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            return $d.length > 0;
        }, {timeout: 3000, interval: 100});

        if (!appeared) {
            // give one more small delay
            await sleep(400);
        }

        // Extra safety pause so React finishes mounting
        await sleep(300);
        return true;
    }

    // Click Done helper
    async function clickDoneAndWaitClose() {
        const $doneButton = await waitVisible('button.positive:visible', {timeout: 4000});
        if ($doneButton) {
            const $exactDone = $doneButton.filter((i, btn) => $(btn).text().trim() === 'Done');
            if ($exactDone.length) {
                log("Clicking Done");
                $exactDone[0].click();
                // Wait until dialog disappears
                await waitForCondition(() => {
                    const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
                    return $d.length === 0;
                }, {timeout: 3500, interval: 120});
                // small extra breathing room
                await sleep(250);
                return true;
            }
        }
        log("Done button not found (when trying to click Done).");
        return false;
    }

    // ----------------- Filling sequence (async) -----------------
    async function fillFieldsAsync(config) {
        log(`Start filling for: ${config.label} (${config.relationshipType})`);

        // 1) Relationship type
        const $relInput = await waitVisible('input.relationship-type', {timeout: 4000});
        if (!$relInput) {
            log("Relationship type input not found — aborting this item.");
            return false;
        }
        log(`Typing relationshipType '${config.relationshipType}'`);
        await typeAndSelect($relInput, config.relationshipType, {charDelay: 40, postSelectWait: 200});

        // 2) Artist
        const $artist = await waitVisible('input[placeholder="Type to search, or paste an MBID"]', {timeout: 4000});
        if (!$artist) {
            log("Artist input not found — aborting this item.");
            return false;
        }
        log(`Typing artist '${config.artist}'`);
        await typeAndSelect($artist, config.artist, {charDelay: 50, postSelectWait: 250});

        // SPECIAL CASE: performed / performer -> skip instrument/vocal/credited-as and click Done
        if (config.relationshipType === 'performed / performer') {
            log("Performed / performer detected — skipping instrument/vocal/credited-as and clicking Done.");
            await clickDoneAndWaitClose();
            log(`Finished performer item: ${config.label}`);
            return true;
        }

        // 3) Instrument or Vocal (only for instruments or vocal types)
        const placeholderName = config.relationshipType === 'instruments' ? 'instrument' : 'vocal';

        // Only attempt placeholder input if relationshipType is 'instruments' or 'vocal'
        if (config.relationshipType === 'instruments' || config.relationshipType === 'vocal') {
            const $inst = await waitVisible(`input[placeholder="${placeholderName}"]`, {timeout: 4000});
            if (!$inst) {
                log(`${placeholderName} input not found — aborting this item.`);
                return false;
            }
            const desired = (config.relationshipType === 'instruments') ? config.instrument : config.vocal;
            if (desired && desired.length > 0) {
                log(`Typing ${placeholderName} '${desired}'`);
                await typeAndSelect($inst, desired, {charDelay: 45, postSelectWait: 300});
            } else {
                log(`No ${placeholderName} value provided, skipping selection.`);
            }
        } else {
            log(`Relationship type '${config.relationshipType}' does not require instrument/vocal step; skipping.`);
        }

        // 4) Credited as: find correct container near the instrument/vocal input
        log("Attempting to fill 'Credited as' field…");
        // Strategy: find the nearest .multiselect that contains an input.attribute-credit or the 'attribute-credit' input visible.
        // We'll search visible attribute-credit inputs first, and then try to ensure it's the correct one by proximity.
        let $creditedInput = $('.attribute-credit:visible');
        if ($creditedInput.length === 0) {
            // fallback: look for input.attribute-credit anywhere inside visible multiselects
            const $multi = $('.multiselect:visible').filter(function() {
                return $(this).find('input[placeholder]').length > 0;
            }).last();
            if ($multi && $multi.length) {
                $creditedInput = $multi.find('input.attribute-credit:visible');
            }
        }

        // Another proximity attempt: find attribute-credit inside last visible .multiselect.* that also contains the placeholder input
        if ($creditedInput.length === 0) {
            const $lastMulti = $('.multiselect:visible').filter((i, el) => {
                return $(el).find(`input[placeholder="${placeholderName}"]`).length > 0;
            }).last();
            if ($lastMulti && $lastMulti.length) {
                $creditedInput = $lastMulti.find('input.attribute-credit:visible');
            }
        }

        // If still not found, try common selector: .multiselect.instrument or .multiselect.vocal
        if ($creditedInput.length === 0) {
            if (config.relationshipType === 'instruments') {
                $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit:visible');
            } else {
                $creditedInput = $('.multiselect.vocal').last().find('input.attribute-credit:visible');
            }
        }

        // Final fallback: any visible input whose name/id contains 'credit'
        if ($creditedInput.length === 0) {
            $creditedInput = $("input:visible").filter((i, el) => {
                const idn = (el.id || '').toLowerCase();
                const name = (el.name || '').toLowerCase();
                const cls = (el.className || '').toLowerCase();
                return idn.includes('credit') || name.includes('credit') || cls.includes('attribute-credit');
            }).first();
        }

        if ($creditedInput && $creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs ?? '';
            // set and dispatch react-friendly events
            setReactValueAndDispatch(el, text);
            // give React a little time
            await sleep(120);
            log(`'Credited as' set to "${text}"`);
        } else {
            log("Could not find credited-as input (it's optional); continuing.");
        }

        // 5) Click Done, but wait until Done appears and is stable
        const doneClicked = await clickDoneAndWaitClose();
        if (doneClicked) {
            log(`Finished item: ${config.label}`);
            return true;
        } else {
            log("Done not clicked (not found) — but continuing.");
            return true;
        }
    }

    // ----------------- Queue to process clicks sequentially -----------------
    const queue = [];
    let processing = false;

    async function processQueue() {
        if (processing) return;
        processing = true;
        while (queue.length) {
            const config = queue.shift();
            try {
                log(`Processing queue item: ${config.label}`);
                // Open dialog (ensures previous is closed and waits until the dialog is stable)
                const opened = await openBatchAddDialog();
                if (!opened) {
                    log("Could not open batch-add dialog — skipping this item.");
                    await sleep(300);
                    continue;
                }

                // Fill all fields and click Done
                await fillFieldsAsync(config);

                // Give small pause before next item to let React settle
                await sleep(300);
            } catch (e) {
                console.error('[AA-add-instrument] Error processing item', e);
                // tiny pause and continue with next item
                await sleep(500);
            }
        }
        processing = false;
    }

    // ----------------- UI: create buttons -----------------
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            // Append (i) or (v) or (p) to button label UI
            const suffix = config.relationshipType === 'instruments' ? ' (i)' :
                           config.relationshipType === 'vocal' ? ' (v)' :
                           config.relationshipType === 'performed / performer' ? ' (p)' : '';
            const buttonText = `${config.label}${suffix}`;

            const $button = $('<button/>', {
                text: buttonText,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`Enqueued "${config.label}" (${config.relationshipType})`);
                // push a shallow copy to avoid mutation issues
                queue.push(Object.assign({}, config));
                processQueue().catch(e => console.error(e));
            });
        });

        log("AA: Injected custom buttons.");
    }

    // Start
    $(document).ready(() => {
        // Wait a bit to ensure page ready
        setTimeout(createCustomButtons, 700);
    });

})();
#+end_example


#+begin_example
// ----------------- UI: create buttons -----------------
function createCustomButtons() {
    const $heading = $(HEADING_SELECTOR);

    if ($heading.length === 0) {
        log("Heading 'Track relationships' not found yet — retrying…");
        setTimeout(createCustomButtons, 500);
        return;
    }

    const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
    $heading.wrap($container);

    // --- NEW: Keyboard shortcut mapping ---
    const SHORTCUTS = {
        "instruments": "1",
        "vocal": "2",
        "performed / performer": "3"
    };

    // Listen globally for shortcuts (Alt+Number)
    document.addEventListener("keydown", e => {
        if (!e.altKey) return;
        const key = e.key;

        const found = ARTIST_BUTTONS.find(cfg =>
            SHORTCUTS[cfg.relationshipType] === key
        );

        if (found) {
            log(`Keyboard shortcut triggered: Alt+${key} → ${found.label}`);
            queue.push(Object.assign({}, found));
            processQueue().catch(e => console.error(e));
        }
    });

    ARTIST_BUTTONS.forEach(config => {

        // Append (i) or (v) or (p) to button label UI
        const suffix = config.relationshipType === 'instruments' ? ' (i)' :
                       config.relationshipType === 'vocal' ? ' (v)' :
                       config.relationshipType === 'performed / performer' ? ' (p)' : '';

        // --- NEW: Icons ---
        const icon = config.relationshipType === 'instruments' ? '🥁 ' :
                     config.relationshipType === 'vocal' ? '🎤 ' :
                     config.relationshipType === 'performed / performer' ? '🎶 ' : '';

        // --- NEW: Color coding ---
        const color =
            config.relationshipType === "instruments" ? "#3182ce" :       // blue
            config.relationshipType === "vocal" ? "#d69e2e" :             // yellow/gold
            config.relationshipType === "performed / performer" ? "#805ad5" : "#38a169"; // purple

        // --- NEW: Shortcut label ---
        const shortcut = SHORTCUTS[config.relationshipType]
            ? ` [Alt+${SHORTCUTS[config.relationshipType]}]`
            : "";

        const buttonText = `${icon}${config.label}${suffix}${shortcut}`;

        const $button = $('<button/>', {
            text: buttonText,
            style: `
                margin-left: 10px;
                background-color: ${color};
                color: white;
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                display: inline-flex;
                align-items: center;
            `
        });

        $heading.parent().append($button);

        $button.on('click', () => {
            log(`Enqueued "${config.label}" (${config.relationshipType})`);
            // push a shallow copy to avoid mutation issues
            queue.push(Object.assign({}, config));
            processQueue().catch(e => console.error(e));
        });
    });

    log("AA: Injected custom buttons.");
}
#+end_example

* gemini

Can the following userscript be fine tuned (especially the timeouts). I can literally watch the script typing, this
should probably be enhanced without breaking the logic itself.

#+begin_example
// ==UserScript==
// @name         BatchAddRelationshipsToRecordings.user.js
// @namespace    https://github.com/vzell/mb-userscripts
// @version      1.0
// @description  Insert artist buttons, open batch-add dialog, reliably fill relationship type (instruments|vocal|performed / performer), artist, instrument/vocal, credited-as, click Done — sequential queue + dialog lifecycle awareness.
// @homepageURL  https://github.com/vzell/mb-userscripts
// @tag          vzell with the help of ChatGPT
// @homepageURL  https://github.com/vzell/mb-userscripts
// @downloadURL  https://raw.githubusercontent.com/vzell/mb-userscripts/master/BatchAddRelationshipsToRecordings.user.js
// @updateURL    https://raw.githubusercontent.com/vzell/mb-userscripts/master/BatchAddRelationshipsToRecordings.user.js
// @match        https://musicbrainz.org/release/*/edit-relationships*
// @grant        none
// @require      https://code.jquery.com/jquery-3.6.0.min.js
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const DEBUG = true;
    const HEADING_SELECTOR = "h2:contains('Track relationships')";

    function log(...args) {
        if (DEBUG) console.log('[AA-add-instrument]', ...args);
    }

    // --- Configuration for multiple Artist buttons ---
    const ARTIST_BUTTONS = [
        {
            label: "Max Weinberg",
            relationshipType: "instruments",
            artist: "Max Weinberg",
            instrument: "drums (drum set)",
            creditedAs: "drums"
        },
        {
            label: "Garry Tallent",
            relationshipType: "instruments",
            artist: "Garry Tallent",
            instrument: "electric bass guitar",
            creditedAs: ""
        },
        {
            label: "Bruce Springsteen",
            relationshipType: "vocal",
            artist: "Bruce Springsteen",
            vocal: "lead vocals",
            creditedAs: ""
        },
        {
            label: "E Street Band",
            relationshipType: "performed / performer",
            artist: "The E Street Band"
        }
        // Add/remove entries as needed
    ];

    // ----------------- Utilities -----------------
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // Wait for an element matching selector that is visible
    async function waitVisible(selector, opts = {}) {
        const timeout = opts.timeout ?? 5000;
        const interval = opts.interval ?? 100;
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const $el = $(selector).filter(':visible');
            if ($el.length) return $el;
            await sleep(interval);
        }
        return null;
    }

    // Wait until no visible dialog exists (used to ensure previous dialog fully closed)
    async function waitDialogClosed(timeout = 3000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            // adjust selector if your dialog uses a specific class; generic attempt:
            const $visibleDialogs = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            if ($visibleDialogs.length === 0) {
                // small extra breathing room so React finishes unmount
                await sleep(200);
                return true;
            }
            await sleep(100);
        }
        return false;
    }

    // Wait until a particular condition returns truthy or times out
    async function waitForCondition(conditionFn, {timeout = 3000, interval = 100} = {}) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            try {
                if (await conditionFn()) return true;
            } catch (e) { /* ignore */ }
            await sleep(interval);
        }
        return false;
    }

    // Set value for React-controlled input and dispatch events
    function setReactValueAndDispatch(el, value) {
        try {
            const nativeSetter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
            if (nativeSetter) nativeSetter.call(el, value);
            else el.value = value;

            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            // some react versions also respond to these:
            el.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } catch (e) {
            // fallback
            el.value = value;
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    // Clear an input cleanly (React-aware)
    function clearInput(el) {
        setReactValueAndDispatch(el, '');
    }

    // Type into autocomplete input character by character and select matching option when available.
    // This function is defensive: it waits for suggestion list, waits for an option starting with prefix (case-insensitive),
    // clicks it, then waits until some sign of selection appears (or a small delay).
    async function typeAndSelect($input, text, {charDelay = 40, postSelectWait = 300, optionSelector = "li[role='option']"} = {}) {
        const el = $input[0];
        if (!el) throw new Error('Input element missing');

        el.focus();

        // Ensure input is empty first (React-friendly)
        clearInput(el);
        await sleep(50);

        // Type characters slowly
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const newValue = el.value + ch;
            setReactValueAndDispatch(el, newValue);
            await sleep(charDelay);
        }

        // At end, give suggestions a moment
        await sleep(120);

        // Wait for a suggestion that startsWith text
        const found = await waitForCondition(() => {
            const $opts = $(optionSelector).filter(':visible');
            if (!$opts.length) return false;
            // prefer exact startsWith (case-insensitive)
            const match = $opts.toArray().find(o => $(o).text().trim().toLowerCase().startsWith(text.toLowerCase()));
            if (match) {
                match.click();
                return true;
            }
            // fallback: any option that includes the text
            const match2 = $opts.toArray().find(o => $(o).text().trim().toLowerCase().includes(text.toLowerCase()));
            if (match2) {
                match2.click();
                return true;
            }
            return false;
        }, {timeout: 3000, interval: 120});

        if (!found) {
            log(`Warning: option for "${text}" not found in suggestions after timeout.`);
        }

        // give React time to update internal state / tokens
        await sleep(postSelectWait);
    }

    // Reliable method: click batch-add button but only AFTER ensuring previous dialog closed
    async function openBatchAddDialog() {
        // Ensure previous closed
        await waitDialogClosed(2000);

        // Find the batch button
        const $batch = $("button.add-item.with-label.batch-add-recording-relationship, button.add-item.batch-add-recording-relationship, button.add-item.with-label").filter(function() {
            const t = $(this).text().toLowerCase();
            return t.includes('batch-add') || t.includes('batch add') || (t.includes('add') && t.includes('record'));
        });

        if ($batch.length === 0) {
            log("Batch-add button not found via selectors");
            return false;
        }

        // Click it
        $batch[0].click();

        // Wait for dialog to appear
        const appeared = await waitForCondition(() => {
            const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
            return $d.length > 0;
        }, {timeout: 3000, interval: 100});

        if (!appeared) {
            // give one more small delay
            await sleep(400);
        }

        // Extra safety pause so React finishes mounting
        await sleep(300);
        return true;
    }

    // Click Done helper
    async function clickDoneAndWaitClose() {
        const $doneButton = await waitVisible('button.positive:visible', {timeout: 4000});
        if ($doneButton) {
            const $exactDone = $doneButton.filter((i, btn) => $(btn).text().trim() === 'Done');
            if ($exactDone.length) {
                log("Clicking Done");
                $exactDone[0].click();
                // Wait until dialog disappears
                await waitForCondition(() => {
                    const $d = $('.modal, .Dialog, .dialog, .ui-dialog').filter(':visible');
                    return $d.length === 0;
                }, {timeout: 3500, interval: 120});
                // small extra breathing room
                await sleep(250);
                return true;
            }
        }
        log("Done button not found (when trying to click Done).");
        return false;
    }

    // ----------------- Filling sequence (async) -----------------
    async function fillFieldsAsync(config) {
        log(`Start filling for: ${config.label} (${config.relationshipType})`);

        // 1) Relationship type
        const $relInput = await waitVisible('input.relationship-type', {timeout: 4000});
        if (!$relInput) {
            log("Relationship type input not found — aborting this item.");
            return false;
        }
        log(`Typing relationshipType '${config.relationshipType}'`);
        await typeAndSelect($relInput, config.relationshipType, {charDelay: 40, postSelectWait: 200});

        // 2) Artist
        const $artist = await waitVisible('input[placeholder="Type to search, or paste an MBID"]', {timeout: 4000});
        if (!$artist) {
            log("Artist input not found — aborting this item.");
            return false;
        }
        log(`Typing artist '${config.artist}'`);
        await typeAndSelect($artist, config.artist, {charDelay: 50, postSelectWait: 250});

        // SPECIAL CASE: performed / performer -> skip instrument/vocal/credited-as and click Done
        if (config.relationshipType === 'performed / performer') {
            log("Performed / performer detected — skipping instrument/vocal/credited-as and clicking Done.");
            await clickDoneAndWaitClose();
            log(`Finished performer item: ${config.label}`);
            return true;
        }

        // 3) Instrument or Vocal (only for instruments or vocal types)
        const placeholderName = config.relationshipType === 'instruments' ? 'instrument' : 'vocal';

        // Only attempt placeholder input if relationshipType is 'instruments' or 'vocal'
        if (config.relationshipType === 'instruments' || config.relationshipType === 'vocal') {
            const $inst = await waitVisible(`input[placeholder="${placeholderName}"]`, {timeout: 4000});
            if (!$inst) {
                log(`${placeholderName} input not found — aborting this item.`);
                return false;
            }
            const desired = (config.relationshipType === 'instruments') ? config.instrument : config.vocal;
            if (desired && desired.length > 0) {
                log(`Typing ${placeholderName} '${desired}'`);
                await typeAndSelect($inst, desired, {charDelay: 45, postSelectWait: 300});
            } else {
                log(`No ${placeholderName} value provided, skipping selection.`);
            }
        } else {
            log(`Relationship type '${config.relationshipType}' does not require instrument/vocal step; skipping.`);
        }

        // 4) Credited as: find correct container near the instrument/vocal input
        log("Attempting to fill 'Credited as' field…");
        // Strategy: find the nearest .multiselect that contains an input.attribute-credit or the 'attribute-credit' input visible.
        // We'll search visible attribute-credit inputs first, and then try to ensure it's the correct one by proximity.
        let $creditedInput = $('.attribute-credit:visible');
        if ($creditedInput.length === 0) {
            // fallback: look for input.attribute-credit anywhere inside visible multiselects
            const $multi = $('.multiselect:visible').filter(function() {
                return $(this).find('input[placeholder]').length > 0;
            }).last();
            if ($multi && $multi.length) {
                $creditedInput = $multi.find('input.attribute-credit:visible');
            }
        }

        // Another proximity attempt: find attribute-credit inside last visible .multiselect.* that also contains the placeholder input
        if ($creditedInput.length === 0) {
            const $lastMulti = $('.multiselect:visible').filter((i, el) => {
                return $(el).find(`input[placeholder="${placeholderName}"]`).length > 0;
            }).last();
            if ($lastMulti && $lastMulti.length) {
                $creditedInput = $lastMulti.find('input.attribute-credit:visible');
            }
        }

        // If still not found, try common selector: .multiselect.instrument or .multiselect.vocal
        if ($creditedInput.length === 0) {
            if (config.relationshipType === 'instruments') {
                $creditedInput = $('.multiselect.instrument').last().find('input.attribute-credit:visible');
            } else {
                $creditedInput = $('.multiselect.vocal').last().find('input.attribute-credit:visible');
            }
        }

        // Final fallback: any visible input whose name/id contains 'credit'
        if ($creditedInput.length === 0) {
            $creditedInput = $("input:visible").filter((i, el) => {
                const idn = (el.id || '').toLowerCase();
                const name = (el.name || '').toLowerCase();
                const cls = (el.className || '').toLowerCase();
                return idn.includes('credit') || name.includes('credit') || cls.includes('attribute-credit');
            }).first();
        }

        if ($creditedInput && $creditedInput.length) {
            const el = $creditedInput[0];
            const text = config.creditedAs ?? '';
            // set and dispatch react-friendly events
            setReactValueAndDispatch(el, text);
            // give React a little time
            await sleep(120);
            log(`'Credited as' set to "${text}"`);
        } else {
            log("Could not find credited-as input (it's optional); continuing.");
        }

        // 5) Click Done, but wait until Done appears and is stable
        const doneClicked = await clickDoneAndWaitClose();
        if (doneClicked) {
            log(`Finished item: ${config.label}`);
            return true;
        } else {
            log("Done not clicked (not found) — but continuing.");
            return true;
        }
    }

    // ----------------- Queue to process clicks sequentially -----------------
    const queue = [];
    let processing = false;

    async function processQueue() {
        if (processing) return;
        processing = true;
        while (queue.length) {
            const config = queue.shift();
            try {
                log(`Processing queue item: ${config.label}`);
                // Open dialog (ensures previous is closed and waits until the dialog is stable)
                const opened = await openBatchAddDialog();
                if (!opened) {
                    log("Could not open batch-add dialog — skipping this item.");
                    await sleep(300);
                    continue;
                }

                // Fill all fields and click Done
                await fillFieldsAsync(config);

                // Give small pause before next item to let React settle
                await sleep(300);
            } catch (e) {
                console.error('[AA-add-instrument] Error processing item', e);
                // tiny pause and continue with next item
                await sleep(500);
            }
        }
        processing = false;
    }

    // ----------------- UI: create buttons -----------------
    function createCustomButtons() {
        const $heading = $(HEADING_SELECTOR);

        if ($heading.length === 0) {
            log("Heading 'Track relationships' not found yet — retrying…");
            setTimeout(createCustomButtons, 500);
            return;
        }

        const $container = $('<div style="display:flex;align-items:center;margin-bottom:5px;"></div>');
        $heading.wrap($container);

        ARTIST_BUTTONS.forEach(config => {
            // Append (i) or (v) or (p) to button label UI
            const suffix = config.relationshipType === 'instruments' ? ' (i)' :
                           config.relationshipType === 'vocal' ? ' (v)' :
                           config.relationshipType === 'performed / performer' ? ' (p)' : '';
            const buttonText = `${config.label}${suffix}`;

            const $button = $('<button/>', {
                text: buttonText,
                style: `
                    margin-left: 10px;
                    background-color: #38a169;
                    color: white;
                    padding: 5px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `
            });

            $heading.parent().append($button);

            $button.on('click', () => {
                log(`Enqueued "${config.label}" (${config.relationshipType})`);
                // push a shallow copy to avoid mutation issues
                queue.push(Object.assign({}, config));
                processQueue().catch(e => console.error(e));
            });
        });

        log("AA: Injected custom buttons.");
    }

    // Start
    $(document).ready(() => {
        // Wait a bit to ensure page ready
        setTimeout(createCustomButtons, 700);
    });

})();
#+end_example
